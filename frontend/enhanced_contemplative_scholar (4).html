<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chemical Computing Aquarium - Multi-Tradition Contemplative Analysis</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@300;400;500&family=Noto+Sans+Devanagari:wght@400;500;600&family=Noto+Sans+Hebrew:wght@400;500;600&display=swap');
    
    :root {
      --primary-gold: #d4af37;
      --secondary-copper: #b87333;
      --tertiary-bronze: #cd7f32;
      --quantum-blue: #00d4ff;
      --void-purple: #6a0dad;
      --enlightenment-white: #f8f8ff;
      --kabbalistic-blue: #0066cc;
      --vedantic-orange: #ff6600;
      --daoist-green: #339933;
      --dark-void: #0a0a0a;
      --darker-void: #050505;
      --surface-dark: #1a1a1a;
      --surface-medium: #2a2a2a;
      --text-primary: #e8e8e8;
      --text-secondary: #b8b8b8;
      --text-muted: #888888;
      --accent-cyan: #00ffff;
      --accent-magenta: #ff00ff;
      --success-color: #00ff88;
      --warning-color: #ffaa00;
      --error-color: #ff4444;
      --border-radius: 8px;
      --border-radius-large: 16px;
      --shadow-void: 0 8px 32px rgba(0, 0, 0, 0.7);
      --transition-smooth: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-elastic: 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: 'Inter', 'Noto Sans Devanagari', 'Noto Sans Hebrew', sans-serif;
      background: radial-gradient(ellipse at center, var(--darker-void), #000000);
      color: var(--text-primary);
      line-height: 1.6;
      overflow: hidden;
      font-weight: 400;
      height: 100vh;
    }
    
    .quantum-grid {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
        linear-gradient(rgba(212, 175, 55, 0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(212, 175, 55, 0.03) 1px, transparent 1px);
      background-size: 50px 50px;
      pointer-events: none;
      z-index: 1;
      animation: grid-flow 20s linear infinite;
    }
    
    @keyframes grid-flow {
      0% { transform: translate(0, 0); }
      100% { transform: translate(50px, 50px); }
    }
    
    .app-container {
      display: grid;
      grid-template-areas: 
        "header header header"
        "traditions-panel aquarium-canvas synthesis-panel";
      grid-template-columns: 350px 1fr 400px;
      grid-template-rows: auto 1fr;
      height: 100vh;
      gap: 1px;
      background: var(--primary-gold);
      z-index: 2;
      position: relative;
    }
    
    .app-header {
      grid-area: header;
      background: linear-gradient(135deg, var(--dark-void), var(--surface-dark));
      border-bottom: 1px solid var(--primary-gold);
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      backdrop-filter: blur(10px);
    }
    
    .header-brand {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .brand-title {
      font-family: 'Crimson Text', serif;
      font-size: 1.75rem;
      font-weight: 600;
      background: linear-gradient(135deg, var(--primary-gold), var(--quantum-blue), var(--void-purple), var(--kabbalistic-blue));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 0 30px rgba(212, 175, 55, 0.5);
    }
    
    .brand-subtitle {
      font-size: 0.875rem;
      color: var(--text-secondary);
      font-weight: 300;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .header-controls {
      display: flex;
      gap: 1rem;
      align-items: center;
    }
    
    .tradition-selector {
      display: flex;
      background: var(--surface-medium);
      border-radius: var(--border-radius);
      padding: 0.25rem;
      border: 1px solid var(--primary-gold);
    }
    
    .tradition-btn {
      padding: 0.4rem 0.8rem;
      border: none;
      background: none;
      color: var(--text-secondary);
      cursor: pointer;
      border-radius: calc(var(--border-radius) - 2px);
      transition: var(--transition-smooth);
      font-size: 0.75rem;
      font-weight: 500;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .tradition-btn.active {
      background: linear-gradient(135deg, var(--primary-gold), var(--quantum-blue));
      color: var(--dark-void);
      box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
    }
    
    .traditions-panel {
      grid-area: traditions-panel;
      background: var(--dark-void);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      border-right: 1px solid var(--surface-dark);
    }
    
    .panel-header {
      background: var(--surface-medium);
      padding: 1rem;
      border-bottom: 1px solid var(--primary-gold);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .panel-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--primary-gold);
      font-family: 'Crimson Text', serif;
    }
    
    .aquarium-controls {
      display: flex;
      gap: 0.5rem;
    }
    
    .control-button {
      padding: 0.25rem 0.5rem;
      border: 1px solid var(--quantum-blue);
      background: none;
      color: var(--quantum-blue);
      cursor: pointer;
      border-radius: 4px;
      transition: var(--transition-smooth);
      font-size: 0.7rem;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .control-button:hover {
      background: var(--quantum-blue);
      color: var(--dark-void);
      box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
    }
    
    .control-button.active {
      background: var(--quantum-blue);
      color: var(--dark-void);
    }
    
    .panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
    }
    
    .tradition-stages {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    
    .stage-card {
      background: linear-gradient(135deg, var(--surface-dark), var(--surface-medium));
      border-radius: var(--border-radius);
      padding: 1rem;
      cursor: pointer;
      transition: var(--transition-elastic);
      border: 1px solid transparent;
      position: relative;
      overflow: hidden;
      user-select: none;
    }
    
    .stage-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(212, 175, 55, 0.1), transparent);
      transition: var(--transition-smooth);
    }
    
    .stage-card:hover::before {
      left: 100%;
    }
    
    .stage-card:hover {
      transform: translateY(-2px);
      border-color: var(--primary-gold);
      box-shadow: var(--shadow-void);
    }
    
    .stage-card.selected {
      border-color: var(--quantum-blue);
      background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(212, 175, 55, 0.1));
      box-shadow: 0 0 20px rgba(0, 212, 255, 0.2);
    }
    
    .stage-card.in-aquarium {
      opacity: 0.5;
      border-color: var(--success-color);
    }
    
    .stage-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.5rem;
    }
    
    .stage-number {
      width: 2.5rem;
      height: 2.5rem;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--primary-gold), var(--secondary-copper));
      color: var(--dark-void);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 0.9rem;
      box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
    }
    
    .stage-symbol {
      font-size: 1.5rem;
      min-width: 2rem;
      text-align: center;
      filter: drop-shadow(0 0 10px currentColor);
    }
    
    .stage-info {
      flex: 1;
    }
    
    .stage-name {
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
    }
    
    .stage-transliteration {
      font-size: 0.8rem;
      color: var(--text-secondary);
      font-style: italic;
      font-family: 'Crimson Text', serif;
    }
    
    .stage-description {
      font-size: 0.8rem;
      color: var(--text-muted);
      line-height: 1.4;
      margin-top: 0.5rem;
    }
    
    .prompt-fragment {
      background: rgba(0, 212, 255, 0.1);
      border: 1px solid var(--quantum-blue);
      border-radius: 4px;
      padding: 0.375rem;
      margin-top: 0.5rem;
      font-size: 0.75rem;
      font-family: 'JetBrains Mono', monospace;
      color: var(--quantum-blue);
      line-height: 1.3;
    }
    
    .aquarium-canvas {
      grid-area: aquarium-canvas;
      background: var(--darker-void);
      position: relative;
      overflow: hidden;
    }
    
    .aquarium-container {
      width: 100%;
      height: 100%;
      position: relative;
      background: radial-gradient(ellipse at center, rgba(0, 212, 255, 0.05), transparent 70%);
    }
    
    .floating-node {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: grab;
      transition: var(--transition-smooth);
      user-select: none;
      z-index: 10;
      backdrop-filter: blur(5px);
      border: 2px solid;
    }
    
    .floating-node:hover {
      transform: scale(1.1);
      z-index: 20;
    }
    
    .floating-node.dragging {
      cursor: grabbing;
      transform: scale(1.2);
      z-index: 30;
      box-shadow: 0 0 30px currentColor;
    }
    
    .floating-node.snapping {
      animation: snap-pulse 0.5s ease-out;
    }
    
    @keyframes snap-pulse {
      0% { transform: scale(1.2); }
      50% { transform: scale(1.4); }
      100% { transform: scale(1.1); }
    }
    
    .node-symbol {
      font-size: 1.5rem;
      text-shadow: 0 0 10px currentColor;
    }
    
    .connection-line {
      position: absolute;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--quantum-blue), transparent);
      opacity: 0.6;
      transform-origin: left center;
      pointer-events: none;
      z-index: 5;
      animation: energy-flow 2s linear infinite;
    }
    
    @keyframes energy-flow {
      0% { opacity: 0.3; }
      50% { opacity: 0.8; }
      100% { opacity: 0.3; }
    }
    
    .synthesis-cluster {
      position: absolute;
      border: 2px dashed var(--primary-gold);
      border-radius: var(--border-radius-large);
      background: rgba(212, 175, 55, 0.1);
      backdrop-filter: blur(10px);
      padding: 1rem;
      min-width: 150px;
      min-height: 150px;
    }
    
    .cluster-label {
      position: absolute;
      top: -10px;
      left: 10px;
      background: var(--primary-gold);
      color: var(--dark-void);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
    }
    
    .synthesis-panel {
      grid-area: synthesis-panel;
      background: var(--dark-void);
      border-left: 1px solid var(--surface-dark);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .synthesis-header {
      background: var(--surface-medium);
      padding: 1rem;
      border-bottom: 1px solid var(--primary-gold);
    }
    
    .synthesis-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--primary-gold);
      margin-bottom: 0.75rem;
      font-family: 'Crimson Text', serif;
    }
    
    .model-selector {
      width: 100%;
      background: var(--darker-void);
      border: 1px solid var(--quantum-blue);
      color: var(--text-primary);
      padding: 0.5rem;
      border-radius: var(--border-radius);
      font-size: 0.875rem;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .synthesis-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 1rem;
      gap: 1rem;
      overflow-y: auto;
    }
    
    .template-section {
      background: linear-gradient(135deg, var(--surface-dark), var(--surface-medium));
      border-radius: var(--border-radius-large);
      padding: 1rem;
      border: 1px solid var(--void-purple);
    }
    
    .section-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--void-purple);
      margin-bottom: 0.75rem;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .template-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }
    
    .template-card {
      background: var(--darker-void);
      border: 1px solid var(--surface-dark);
      border-radius: var(--border-radius);
      padding: 0.75rem;
      cursor: pointer;
      transition: var(--transition-smooth);
    }
    
    .template-card:hover {
      border-color: var(--quantum-blue);
      background: var(--surface-dark);
      box-shadow: 0 0 15px rgba(0, 212, 255, 0.1);
    }
    
    .template-card.active {
      border-color: var(--primary-gold);
      background: linear-gradient(135deg, rgba(212, 175, 55, 0.1), rgba(106, 13, 173, 0.1));
      box-shadow: 0 0 20px rgba(212, 175, 55, 0.2);
    }
    
    .template-name {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
    }
    
    .template-description {
      font-size: 0.75rem;
      color: var(--text-secondary);
      line-height: 1.3;
    }
    
    .synthesis-operations {
      background: var(--darker-void);
      border: 1px dashed var(--primary-gold);
      border-radius: var(--border-radius);
      padding: 0.75rem;
      min-height: 80px;
      margin-bottom: 0.75rem;
    }
    
    .operation-tag {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      background: linear-gradient(135deg, rgba(212, 175, 55, 0.2), rgba(0, 212, 255, 0.1));
      color: var(--text-primary);
      padding: 0.375rem 0.75rem;
      margin: 0.25rem;
      border-radius: var(--border-radius);
      font-size: 0.75rem;
      border: 1px solid rgba(212, 175, 55, 0.3);
    }
    
    .tag-remove {
      cursor: pointer;
      color: var(--error-color);
      font-weight: bold;
      padding: 0.125rem;
      border-radius: 50%;
      transition: var(--transition-smooth);
    }
    
    .tag-remove:hover {
      background: var(--error-color);
      color: var(--text-primary);
    }
    
    .synthesis-textarea {
      background: var(--darker-void);
      border: 1px solid var(--quantum-blue);
      border-radius: var(--border-radius);
      padding: 0.75rem;
      color: var(--text-primary);
      font-family: 'Inter', sans-serif;
      font-size: 0.85rem;
      resize: none;
      min-height: 120px;
      line-height: 1.5;
    }
    
    .synthesis-textarea:focus {
      outline: none;
      border-color: var(--primary-gold);
      box-shadow: 0 0 20px rgba(212, 175, 55, 0.2);
    }
    
    .response-area {
      background: var(--darker-void);
      border: 1px solid var(--void-purple);
      border-radius: var(--border-radius);
      padding: 0.75rem;
      color: var(--text-primary);
      font-family: 'Inter', sans-serif;
      font-size: 0.85rem;
      overflow-y: auto;
      white-space: pre-wrap;
      min-height: 120px;
      line-height: 1.5;
    }
    
    .api-controls {
      display: flex;
      gap: 0.75rem;
      align-items: center;
      margin-top: 0.75rem;
    }
    
    .primary-button {
      background: linear-gradient(135deg, var(--primary-gold), var(--quantum-blue));
      color: var(--dark-void);
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-weight: 600;
      font-size: 0.85rem;
      transition: var(--transition-elastic);
      flex: 1;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .primary-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(212, 175, 55, 0.3);
    }
    
    .primary-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .secondary-button {
      background: var(--error-color);
      color: var(--text-primary);
      border: none;
      padding: 0.75rem 1rem;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-weight: 500;
      font-size: 0.85rem;
      transition: var(--transition-smooth);
    }
    
    .loading-spinner {
      width: 1.5rem;
      height: 1.5rem;
      border: 2px solid var(--surface-dark);
      border-radius: 50%;
      border-top-color: var(--quantum-blue);
      animation: quantum-spin 1s linear infinite;
    }
    
    @keyframes quantum-spin {
      to { transform: rotate(360deg); }
    }
    
    .settings-section {
      background: linear-gradient(135deg, var(--surface-dark), var(--surface-medium));
      border-radius: var(--border-radius-large);
      padding: 1rem;
      border: 1px solid var(--secondary-copper);
    }
    
    .setting-group {
      margin-bottom: 0.75rem;
    }
    
    .setting-label {
      display: block;
      margin-bottom: 0.5rem;
      font-size: 0.8rem;
      color: var(--text-secondary);
      font-weight: 500;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .setting-input {
      width: 100%;
      background: var(--darker-void);
      border: 1px solid var(--surface-dark);
      color: var(--text-primary);
      padding: 0.5rem;
      border-radius: var(--border-radius);
      font-size: 0.8rem;
      transition: var(--transition-smooth);
    }
    
    .setting-input:focus {
      outline: none;
      border-color: var(--quantum-blue);
      box-shadow: 0 0 15px rgba(0, 212, 255, 0.2);
    }
    
    .range-group {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    
    .range-value {
      min-width: 2.5rem;
      text-align: right;
      font-size: 0.8rem;
      color: var(--quantum-blue);
      font-weight: 600;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .notification {
      position: fixed;
      bottom: 1.5rem;
      right: 1.5rem;
      padding: 1rem 1.5rem;
      border-radius: var(--border-radius);
      color: var(--text-primary);
      z-index: 1000;
      animation: quantum-slideIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      font-weight: 500;
      min-width: 250px;
      box-shadow: var(--shadow-void);
      border: 1px solid;
      backdrop-filter: blur(10px);
    }
    
    .notification.success {
      background: linear-gradient(135deg, rgba(0, 255, 136, 0.9), rgba(0, 212, 255, 0.7));
      border-color: var(--success-color);
      color: var(--dark-void);
    }
    
    .notification.error {
      background: linear-gradient(135deg, rgba(255, 68, 68, 0.9), rgba(255, 170, 0, 0.7));
      border-color: var(--error-color);
    }
    
    .notification.warning {
      background: linear-gradient(135deg, rgba(255, 170, 0, 0.9), rgba(212, 175, 55, 0.7));
      border-color: var(--warning-color);
      color: var(--dark-void);
    }
    
    @keyframes quantum-slideIn {
      from { 
        transform: translateX(100%) scale(0.8); 
        opacity: 0; 
      }
      to { 
        transform: translateX(0) scale(1); 
        opacity: 1; 
      }
    }

    .tradition-metadata {
      background: var(--surface-medium);
      border-radius: var(--border-radius-large);
      padding: 1rem;
      margin-top: 1rem;
      border: 1px solid var(--void-purple);
    }
    
    .metadata-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--void-purple);
      margin-bottom: 0.75rem;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .metadata-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      font-size: 0.8rem;
    }
    
    .metadata-label {
      color: var(--text-secondary);
    }
    
    .metadata-value {
      color: var(--quantum-blue);
      font-family: 'JetBrains Mono', monospace;
    }

    /* Tradition-specific styling */
    .buddhist-node {
      background: linear-gradient(135deg, rgba(255, 165, 0, 0.3), rgba(139, 69, 19, 0.2));
      border-color: #ff8c00;
      color: #ff8c00;
    }
    
    .alchemical-node {
      background: linear-gradient(135deg, rgba(212, 175, 55, 0.3), rgba(184, 115, 51, 0.2));
      border-color: var(--primary-gold);
      color: var(--primary-gold);
    }
    
    .kabbalistic-node {
      background: linear-gradient(135deg, rgba(0, 102, 204, 0.3), rgba(106, 13, 173, 0.2));
      border-color: var(--kabbalistic-blue);
      color: var(--kabbalistic-blue);
    }
    
    .vedantic-node {
      background: linear-gradient(135deg, rgba(255, 102, 0, 0.3), rgba(255, 140, 0, 0.2));
      border-color: var(--vedantic-orange);
      color: var(--vedantic-orange);
    }
    
    .daoist-node {
      background: linear-gradient(135deg, rgba(51, 153, 51, 0.3), rgba(34, 139, 34, 0.2));
      border-color: var(--daoist-green);
      color: var(--daoist-green);
    }
    
    /* Responsive Design */
    @media (max-width: 1400px) {
      .app-container {
        grid-template-columns: 300px 1fr 350px;
      }
    }
    
    @media (max-width: 1200px) {
      .app-container {
        grid-template-columns: 280px 1fr 320px;
      }
    }
    
    @media (max-width: 768px) {
      .app-container {
        grid-template-areas: 
          "header"
          "aquarium-canvas"
          "traditions-panel"
          "synthesis-panel";
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr auto auto;
      }
      
      .traditions-panel,
      .synthesis-panel {
        max-height: 40vh;
      }
    }
    
    /* Accessibility */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }
    
    /* High contrast mode */
    @media (prefers-contrast: high) {
      :root {
        --text-primary: #ffffff;
        --text-secondary: #cccccc;
        --primary-gold: #ffff00;
        --quantum-blue: #00ffff;
      }
    }

    /* Drop zones */
    .drop-zone {
      border-color: var(--success-color);
      background: rgba(0, 255, 136, 0.1);
    }
  </style>
</head>
<body>
  <div class="quantum-grid"></div>
  
  <div class="app-container">
    <header class="app-header">
      <div class="header-brand">
        <div>
          <div class="brand-title">Chemical Computing Aquarium</div>
          <div class="brand-subtitle">Multi-Tradition Contemplative Synthesis Platform</div>
        </div>
      </div>
      <div class="header-controls">
        <div class="tradition-selector">
          <button class="tradition-btn active" data-tradition="buddhist">Buddhist</button>
          <button class="tradition-btn" data-tradition="alchemical">Alchemical</button>
          <button class="tradition-btn" data-tradition="kabbalistic">Kabbalistic</button>
          <button class="tradition-btn" data-tradition="vedantic">Vedantic</button>
          <button class="tradition-btn" data-tradition="daoist">Daoist</button>
        </div>
      </div>
    </header>

    <aside class="traditions-panel">
      <div class="panel-header">
        <div class="panel-title">Contemplative Traditions</div>
        <div class="aquarium-controls">
          <button class="control-button" id="reset-aquarium">Reset</button>
          <button class="control-button" id="animate-physics">Physics</button>
          <button class="control-button" id="clear-all">Clear</button>
        </div>
      </div>
      <div class="panel-content">
        <div class="tradition-stages" id="tradition-stages">
          <!-- Content populated by JavaScript -->
        </div>
        
        <div class="tradition-metadata">
          <div class="metadata-title">Tradition Metrics</div>
          <div class="metadata-item">
            <span class="metadata-label">Elements:</span>
            <span class="metadata-value" id="tradition-elements">12</span>
          </div>
          <div class="metadata-item">
            <span class="metadata-label">In Aquarium:</span>
            <span class="metadata-value" id="aquarium-count">0</span>
          </div>
          <div class="metadata-item">
            <span class="metadata-label">Active Bonds:</span>
            <span class="metadata-value" id="active-bonds">0</span>
          </div>
          <div class="metadata-item">
            <span class="metadata-label">Synthesis Ops:</span>
            <span class="metadata-value" id="synthesis-operations">0</span>
          </div>
        </div>
      </div>
    </aside>

    <main class="aquarium-canvas">
      <div class="aquarium-container" id="aquarium-container">
        <!-- Floating nodes and connections will be added here -->
      </div>
    </main>

    <aside class="synthesis-panel">
      <div class="synthesis-header">
        <div class="synthesis-title">Synthesis Laboratory</div>
        <select class="model-selector" id="model-select">
          <option value="openai/gpt-4o">GPT-4o</option>
          <option value="anthropic/claude-3.5-sonnet">Claude 3.5 Sonnet</option>
          <option value="anthropic/claude-3-haiku">Claude 3 Haiku</option>
          <option value="openai/gpt-3.5-turbo">GPT-3.5 Turbo</option>
          <option value="meta/llama-3.1-70b-instruct">Llama 3.1 70B</option>
        </select>
      </div>
      <div class="synthesis-content">
        <div class="template-section">
          <div class="section-title">Synthesis Frameworks</div>
          <div class="template-grid" id="template-grid">
            <!-- Templates populated by JavaScript -->
          </div>
          <div class="synthesis-operations" id="synthesis-operations">
            <em style="color: var(--text-muted);">Drag nodes together to create synthesis operations</em>
          </div>
        </div>

        <div class="setting-group">
          <label class="setting-label">Synthesis Prompt</label>
          <textarea class="synthesis-textarea" id="prompt-input" placeholder="Multi-tradition synthesis prompt will be constructed here..."></textarea>
        </div>

        <div class="setting-group">
          <label class="setting-label">AI Response</label>
          <div class="response-area" id="response-area"></div>
        </div>

        <div class="api-controls">
          <button class="primary-button" id="send-request">Synthesize</button>
          <button class="secondary-button" id="cancel-request" style="display: none;">Cancel</button>
          <div class="loading-spinner" id="loading-spinner" style="display: none;"></div>
        </div>

        <div class="settings-section">
          <div class="section-title">Configuration</div>
          
          <div class="setting-group">
            <label class="setting-label">Temperature</label>
            <div class="range-group">
              <input type="range" class="setting-input" id="temperature-range" min="0" max="1" step="0.1" value="0.7">
              <span class="range-value" id="temperature-value">0.7</span>
            </div>
          </div>
          
          <div class="setting-group">
            <label class="setting-label">Max Tokens</label>
            <div class="range-group">
              <input type="range" class="setting-input" id="tokens-range" min="200" max="2000" step="100" value="1200">
              <span class="range-value" id="tokens-value">1200</span>
            </div>
          </div>
        </div>
      </div>
    </aside>
  </div>

  <div id="notification" class="notification" style="display: none;">
    <span id="notification-text"></span>
  </div>

  <script>
    // Enhanced Multi-Tradition Data Structures
    const BUDDHIST_NIDANAS = [
      { 
        id: 'avidya', 
        number: 1, 
        name: 'अविद्या', 
        transliteration: 'Avidyā', 
        chinese: '無明',
        english: 'Fundamental Ignorance',
        description: 'Primordial ignorance regarding the nature of reality and interdependence',
        category: 'Root Cause',
        temporal: 'Past Life',
        color: '#ff8c00',
        weight: 10,
        promptFragment: 'primordial ignorance veiling the interdependent nature of phenomena, creating the illusion of inherent existence'
      },
      { 
        id: 'samskara', 
        number: 2, 
        name: 'संस्कार', 
        transliteration: 'Saṃskāra', 
        chinese: '行',
        english: 'Mental Formations',
        description: 'Karmic formations and volitional activities arising from ignorance',
        category: 'Causal Factor',
        temporal: 'Past Life',
        color: '#4682b4',
        weight: 8,
        promptFragment: 'volitional formations and karmic imprints that condition future experience through habitual patterns'
      },
      { 
        id: 'vijnana', 
        number: 3, 
        name: 'विज्ञान', 
        transliteration: 'Vijñāna', 
        chinese: '識',
        english: 'Consciousness',
        description: 'Discriminating consciousness that enables subject-object duality',
        category: 'Cognitive Base',
        temporal: 'Present Life',
        color: '#708090',
        weight: 9,
        promptFragment: 'discriminating consciousness that establishes the subject-object duality fundamental to experience'
      },
      { 
        id: 'namarupa', 
        number: 4, 
        name: 'नामरूप', 
        transliteration: 'Nāmarūpa', 
        chinese: '名色',
        english: 'Name and Form',
        description: 'Psychophysical organism emerging from consciousness',
        category: 'Embodiment',
        temporal: 'Present Life',
        color: '#800080',
        weight: 7,
        promptFragment: 'psychophysical organism comprising mental factors (nama) and material form (rupa) as vehicle for experience'
      },
      { 
        id: 'sadayatana', 
        number: 5, 
        name: 'षडायतन', 
        transliteration: 'Ṣaḍāyatana', 
        chinese: '六入',
        english: 'Six Sense Spheres',
        description: 'Development of six sense faculties and their objects',
        category: 'Perceptual Apparatus',
        temporal: 'Present Life',
        color: '#c0c0c0',
        weight: 6,
        promptFragment: 'six sense doors (eye, ear, nose, tongue, body, mind) through which contact with phenomena occurs'
      },
      { 
        id: 'sparsa', 
        number: 6, 
        name: 'स्पर्श', 
        transliteration: 'Sparśa', 
        chinese: '觸',
        english: 'Contact',
        description: 'Contact between sense faculties, objects, and consciousness',
        category: 'Perceptual Process',
        temporal: 'Present Life',
        color: '#e6e6fa',
        weight: 5,
        promptFragment: 'meeting of sense faculty, object, and consciousness giving rise to immediate awareness'
      },
      { 
        id: 'vedana', 
        number: 7, 
        name: 'वेदना', 
        transliteration: 'Vedanā', 
        chinese: '受',
        english: 'Feeling',
        description: 'Hedonic tone of experience (pleasant, unpleasant, neutral)',
        category: 'Affective Response',
        temporal: 'Present Life',
        color: '#ffd700',
        weight: 7,
        promptFragment: 'feeling-tone that colors every moment of experience as pleasant, unpleasant, or neutral'
      },
      { 
        id: 'trishna', 
        number: 8, 
        name: 'तृष्णा', 
        transliteration: 'Tṛṣṇā', 
        chinese: '愛',
        english: 'Craving',
        description: 'Thirst for sensual pleasures, existence, and non-existence',
        category: 'Reactive Pattern',
        temporal: 'Present Life',
        color: '#ff6347',
        weight: 8,
        promptFragment: 'craving and thirst that drives the search for satisfaction in temporary phenomena'
      },
      { 
        id: 'upadana', 
        number: 9, 
        name: 'उपादान', 
        transliteration: 'Upādāna', 
        chinese: '取',
        english: 'Grasping',
        description: 'Clinging to views, sensuality, rituals, and self-theories',
        category: 'Attachment Process',
        temporal: 'Present Life',
        color: '#2f4f4f',
        weight: 7,
        promptFragment: 'grasping and clinging to views, pleasures, rituals, and theories of self-identity'
      },
      { 
        id: 'bhava', 
        number: 10, 
        name: 'भव', 
        transliteration: 'Bhava', 
        chinese: '有',
        english: 'Becoming',
        description: 'Process of becoming and karmic potential for future birth',
        category: 'Generative Process',
        temporal: 'Present Life',
        color: '#9932cc',
        weight: 6,
        promptFragment: 'becoming and the karmic momentum that propels consciousness toward future manifestation'
      },
      { 
        id: 'jati', 
        number: 11, 
        name: 'जाति', 
        transliteration: 'Jāti', 
        chinese: '生',
        english: 'Birth',
        description: 'Manifestation in new form of existence',
        category: 'Manifestation',
        temporal: 'Future Life',
        color: '#ff1493',
        weight: 5,
        promptFragment: 'birth and manifestation into new forms of existence conditioned by previous actions'
      },
      { 
        id: 'jaramarana', 
        number: 12, 
        name: 'जरामरण', 
        transliteration: 'Jarāmaraṇa', 
        chinese: '老死',
        english: 'Aging and Death',
        description: 'Inevitable decay, death, and suffering of embodied existence',
        category: 'Dissolution',
        temporal: 'Future Life',
        color: '#696969',
        weight: 6,
        promptFragment: 'aging, death, and dissolution that complete the cycle of conditioned existence'
      }
    ];

    const ALCHEMICAL_OPERATIONS = [
      { 
        id: 'calcination', 
        number: 1, 
        name: 'Calcination', 
        symbol: '🜂', 
        latin: 'Calcinatio',
        english: 'Heating to Ashes',
        description: 'Burning away ego attachments and false identifications through spiritual fire',
        category: 'Purification',
        element: 'Fire',
        stage: 'Nigredo',
        color: '#ff4500',
        weight: 9,
        promptFragment: 'spiritual fire that burns away ego attachments and false identifications, reducing the crude material to ash'
      },
      { 
        id: 'dissolution', 
        number: 2, 
        name: 'Dissolution', 
        symbol: '🜄', 
        latin: 'Solutio',
        english: 'Liquefaction',
        description: 'Breaking down rigid mental structures through emotional flow',
        category: 'Breakdown',
        element: 'Water',
        stage: 'Nigredo',
        color: '#1e90ff',
        weight: 8,
        promptFragment: 'watery dissolution that breaks down rigid mental structures through emotional flow and fluidity'
      },
      { 
        id: 'separation', 
        number: 3, 
        name: 'Separation', 
        symbol: '🜅', 
        latin: 'Separatio',
        english: 'Discrimination',
        description: 'Discerning essence from illusion through refined awareness',
        category: 'Discernment',
        element: 'Air',
        stage: 'Albedo',
        color: '#32cd32',
        weight: 7,
        promptFragment: 'discriminating separation that isolates the pure essence from contaminating substances through refined awareness'
      },
      { 
        id: 'conjunction', 
        number: 4, 
        name: 'Conjunction', 
        symbol: '☊', 
        latin: 'Coniunctio',
        english: 'Sacred Marriage',
        description: 'Union of purified opposites in conscious integration',
        category: 'Integration',
        element: 'Earth',
        stage: 'Albedo',
        color: '#ff69b4',
        weight: 8,
        promptFragment: 'sacred marriage and conscious union of purified opposites, reconciling polarities in higher synthesis'
      },
      { 
        id: 'fermentation', 
        number: 5, 
        name: 'Fermentation', 
        symbol: '🜇', 
        latin: 'Fermentatio',
        english: 'Living Process',
        description: 'Awakening divine essence through spiritual fermentation',
        category: 'Vivification',
        element: 'Spirit',
        stage: 'Citrinitas',
        color: '#9370db',
        weight: 6,
        promptFragment: 'living fermentation that awakens the divine essence through organic spiritual transformation'
      },
      { 
        id: 'distillation', 
        number: 6, 
        name: 'Distillation', 
        symbol: '🜈', 
        latin: 'Distillatio',
        english: 'Purification',
        description: 'Extracting pure essence through repeated refinement',
        category: 'Refinement',
        element: 'Fire',
        stage: 'Citrinitas',
        color: '#40e0d0',
        weight: 7,
        promptFragment: 'distillation process that extracts the purest essence through repeated cycles of refinement and concentration'
      },
      { 
        id: 'coagulation', 
        number: 7, 
        name: 'Coagulation', 
        symbol: '🜉', 
        latin: 'Coagulatio',
        english: 'Crystallization',
        description: 'Stabilizing awakened consciousness in material form',
        category: 'Stabilization',
        element: 'Earth',
        stage: 'Rubedo',
        color: '#daa520',
        weight: 9,
        promptFragment: 'coagulation that crystallizes and stabilizes awakened consciousness in permanent material form'
      },
      { 
        id: 'sublimation', 
        number: 8, 
        name: 'Sublimation', 
        symbol: '🜊', 
        latin: 'Sublimatio',
        english: 'Spiritual Ascent',
        description: 'Direct transformation from material to spiritual without intermediate stages',
        category: 'Transcendence',
        element: 'Air',
        stage: 'Rubedo',
        color: '#e6e6fa',
        weight: 5,
        promptFragment: 'sublimation enabling direct transformation from material to spiritual realms without intermediate stages'
      },
      { 
        id: 'multiplication', 
        number: 9, 
        name: 'Multiplication', 
        symbol: '🜋', 
        latin: 'Multiplicatio',
        english: 'Amplification',
        description: 'Increasing transformative power through iterative refinement',
        category: 'Enhancement',
        element: 'Spirit',
        stage: 'Rubedo',
        color: '#ffd700',
        weight: 6,
        promptFragment: 'multiplication that amplifies transformative power through iterative cycles of refinement and enhancement'
      },
      { 
        id: 'projection', 
        number: 10, 
        name: 'Projection', 
        symbol: '🜌', 
        latin: 'Proiectio',
        english: 'Transmission',
        description: 'Projecting transformative power onto base matter of world',
        category: 'Manifestation',
        element: 'All',
        stage: 'Rubedo',
        color: '#ff6347',
        weight: 7,
        promptFragment: 'projection of perfected transformative power onto the base matter of the external world'
      },
      { 
        id: 'putrefaction', 
        number: 11, 
        name: 'Putrefaction', 
        symbol: '🜍', 
        latin: 'Putrefactio',
        english: 'Necessary Decay',
        description: 'Embracing death of old identity as prerequisite for rebirth',
        category: 'Dissolution',
        element: 'Water',
        stage: 'Nigredo',
        color: '#2f4f4f',
        weight: 8,
        promptFragment: 'putrefaction and necessary decay of old identity as essential prerequisite for spiritual rebirth'
      },
      { 
        id: 'congelation', 
        number: 12, 
        name: 'Congelation', 
        symbol: '🜎', 
        latin: 'Congelatio',
        english: 'Perfect Crystallization',
        description: 'Final crystallization into philosopher\'s stone of integrated being',
        category: 'Completion',
        element: 'Stone',
        stage: 'Rubedo',
        color: '#9932cc',
        weight: 10,
        promptFragment: 'final congelation crystallizing into the philosopher\'s stone of perfectly integrated being'
      }
    ];

    const KABBALISTIC_SEPHIROT = [
      {
        id: 'kether',
        number: 1,
        name: 'כתר',
        transliteration: 'Kether',
        english: 'Crown',
        description: 'The Divine Crown, source of all emanation and ineffable unity',
        category: 'Supernal',
        world: 'Atziluth',
        color: '#ffffff',
        weight: 10,
        promptFragment: 'divine crown and ineffable source of all emanation, the hidden unity beyond comprehension'
      },
      {
        id: 'chochmah',
        number: 2,
        name: 'חכמה',
        transliteration: 'Chochmah',
        english: 'Wisdom',
        description: 'Primordial Wisdom, the first flash of divine insight',
        category: 'Supernal',
        world: 'Atziluth',
        color: '#808080',
        weight: 9,
        promptFragment: 'primordial wisdom as the first flash of divine insight, pure undifferentiated knowing'
      },
      {
        id: 'binah',
        number: 3,
        name: 'בינה',
        transliteration: 'Binah',
        english: 'Understanding',
        description: 'Divine Understanding that gives form to Wisdom',
        category: 'Supernal',
        world: 'Atziluth',
        color: '#000000',
        weight: 9,
        promptFragment: 'divine understanding that receives and gives form to primordial wisdom, the divine mother'
      },
      {
        id: 'chesed',
        number: 4,
        name: 'חסד',
        transliteration: 'Chesed',
        english: 'Loving-kindness',
        description: 'Divine mercy and expansive love without boundaries',
        category: 'Constructive',
        world: 'Briah',
        color: '#0066ff',
        weight: 8,
        promptFragment: 'divine loving-kindness and expansive mercy flowing without boundaries or limitation'
      },
      {
        id: 'gevurah',
        number: 5,
        name: 'גבורה',
        transliteration: 'Gevurah',
        english: 'Strength',
        description: 'Divine strength and judgment that creates boundaries',
        category: 'Restrictive',
        world: 'Briah',
        color: '#ff0000',
        weight: 8,
        promptFragment: 'divine strength and rigorous judgment that creates necessary boundaries and limitations'
      },
      {
        id: 'tiphereth',
        number: 6,
        name: 'תפארת',
        transliteration: 'Tiphereth',
        english: 'Beauty',
        description: 'Divine beauty balancing mercy and judgment',
        category: 'Harmonizing',
        world: 'Briah',
        color: '#ffff00',
        weight: 9,
        promptFragment: 'divine beauty and perfect harmony balancing mercy and judgment in radiant synthesis'
      },
      {
        id: 'netzach',
        number: 7,
        name: 'נצח',
        transliteration: 'Netzach',
        english: 'Victory',
        description: 'Divine victory and enduring persistence of divine will',
        category: 'Active',
        world: 'Yetzirah',
        color: '#00ff00',
        weight: 7,
        promptFragment: 'divine victory and enduring persistence that ensures the triumph of divine will'
      },
      {
        id: 'hod',
        number: 8,
        name: 'הוד',
        transliteration: 'Hod',
        english: 'Glory',
        description: 'Divine glory and humble surrender to higher will',
        category: 'Receptive',
        world: 'Yetzirah',
        color: '#ff8000',
        weight: 7,
        promptFragment: 'divine glory revealed through humble surrender and acceptance of higher divine will'
      },
      {
        id: 'yesod',
        number: 9,
        name: 'יסוד',
        transliteration: 'Yesod',
        english: 'Foundation',
        description: 'Foundation connecting higher emanations to material reality',
        category: 'Connective',
        world: 'Yetzirah',
        color: '#800080',
        weight: 8,
        promptFragment: 'divine foundation that channels and connects higher emanations to material manifestation'
      },
      {
        id: 'malkuth',
        number: 10,
        name: 'מלכות',
        transliteration: 'Malkuth',
        english: 'Kingdom',
        description: 'Divine kingdom manifested in material reality',
        category: 'Material',
        world: 'Asiyah',
        color: '#8b4513',
        weight: 6,
        promptFragment: 'divine kingdom manifested in material reality, the receptive vessel for all higher emanations'
      }
    ];

    const VEDANTIC_STAGES = [
      {
        id: 'annamaya',
        number: 1,
        name: 'अन्नमय',
        transliteration: 'Annamaya kosha',
        english: 'Food Sheath',
        description: 'Physical body sustained by food and material nourishment',
        category: 'Gross',
        level: 'Sthula',
        color: '#8b4513',
        weight: 5,
        promptFragment: 'gross physical sheath sustained by food and material elements of existence'
      },
      {
        id: 'pranamaya',
        number: 2,
        name: 'प्राणमय',
        transliteration: 'Pranamaya kosha',
        english: 'Vital Sheath',
        description: 'Vital energy body governing life force and breath',
        category: 'Subtle',
        level: 'Sukshma',
        color: '#ff6600',
        weight: 6,
        promptFragment: 'vital energy sheath governing life force, breath, and subtle physiological processes'
      },
      {
        id: 'manomaya',
        number: 3,
        name: 'मनोमय',
        transliteration: 'Manomaya kosha',
        english: 'Mental Sheath',
        description: 'Mind and emotional responses to sensory experience',
        category: 'Subtle',
        level: 'Sukshma',
        color: '#00ccff',
        weight: 7,
        promptFragment: 'mental sheath encompassing mind, emotions, and reactive responses to sensory experience'
      },
      {
        id: 'vijnanamaya',
        number: 4,
        name: 'विज्ञानमय',
        transliteration: 'Vijnanamaya kosha',
        english: 'Wisdom Sheath',
        description: 'Higher intellect and discriminating wisdom',
        category: 'Causal',
        level: 'Karana',
        color: '#9933ff',
        weight: 8,
        promptFragment: 'wisdom sheath of higher intellect and discriminating awareness that discerns real from unreal'
      },
      {
        id: 'anandamaya',
        number: 5,
        name: 'आनन्दमय',
        transliteration: 'Anandamaya kosha',
        english: 'Bliss Sheath',
        description: 'Innermost sheath of pure bliss and spiritual joy',
        category: 'Causal',
        level: 'Karana',
        color: '#ffcc00',
        weight: 9,
        promptFragment: 'innermost bliss sheath of pure spiritual joy and unconditional happiness'
      },
      {
        id: 'atman',
        number: 6,
        name: 'आत्मन्',
        transliteration: 'Atman',
        english: 'True Self',
        description: 'Pure consciousness beyond all sheaths and limitations',
        category: 'Absolute',
        level: 'Turiya',
        color: '#ffffff',
        weight: 10,
        promptFragment: 'pure consciousness and true Self beyond all sheaths, limitations, and modifications'
      }
    ];

    const DAOIST_TRANSFORMATIONS = [
      {
        id: 'jing',
        number: 1,
        name: '精',
        transliteration: 'Jing',
        english: 'Essence',
        description: 'Fundamental essence and vital substance of being',
        category: 'Foundation',
        element: 'Water',
        color: '#003366',
        weight: 8,
        promptFragment: 'fundamental essence and vital substance that forms the foundation of life and consciousness'
      },
      {
        id: 'qi',
        number: 2,
        name: '氣',
        transliteration: 'Qi',
        english: 'Vital Energy',
        description: 'Life force energy flowing through all existence',
        category: 'Dynamic',
        element: 'Air',
        color: '#66cc66',
        weight: 9,
        promptFragment: 'vital energy and life force that animates and flows through all manifestations of existence'
      },
      {
        id: 'shen',
        number: 3,
        name: '神',
        transliteration: 'Shen',
        english: 'Spirit',
        description: 'Spiritual consciousness and divine awareness',
        category: 'Transcendent',
        element: 'Fire',
        color: '#ff3300',
        weight: 10,
        promptFragment: 'spiritual consciousness and divine awareness that transcends ordinary mental limitations'
      },
      {
        id: 'wu',
        number: 4,
        name: '無',
        transliteration: 'Wu',
        english: 'Emptiness',
        description: 'Primordial emptiness and creative void',
        category: 'Source',
        element: 'Void',
        color: '#000000',
        weight: 10,
        promptFragment: 'primordial emptiness and creative void from which all manifestation spontaneously arises'
      },
      {
        id: 'you',
        number: 5,
        name: '有',
        transliteration: 'You',
        english: 'Being',
        description: 'Manifest existence emerging from emptiness',
        category: 'Manifestation',
        element: 'Earth',
        color: '#996633',
        weight: 7,
        promptFragment: 'manifest being and existence emerging from the creative potential of primordial emptiness'
      },
      {
        id: 'wuwei',
        number: 6,
        name: '無為',
        transliteration: 'Wu Wei',
        english: 'Non-Action',
        description: 'Effortless action in harmony with natural flow',
        category: 'Practice',
        element: 'Flow',
        color: '#6699ff',
        weight: 8,
        promptFragment: 'effortless non-action that moves in perfect harmony with the natural flow of existence'
      }
    ];

    // Enhanced Synthesis Templates for Multi-Tradition Analysis
    const SYNTHESIS_TEMPLATES = {
      comparative_phenomenology: {
        name: "Comparative Phenomenology",
        description: "Cross-tradition phenomenological analysis",
        template: `Conduct comparative phenomenological analysis of the following contemplative elements across traditions: {elements}

**Phenomenological Framework:**
1. **Intentional Structure**: Examine consciousness-object correlations in each tradition
2. **Temporal Constitution**: Analyze retention-protention synthesis across contemplative stages  
3. **Intersubjective Validation**: Compare methods of validating contemplative insights
4. **Epoché Variations**: Different approaches to bracketing natural attitude
5. **Embodied Experience**: Role of somatic awareness in each tradition

**Cross-Traditional Questions:**
- How do Buddhist dependent origination, alchemical circulation, Kabbalistic emanation, Vedantic kosha analysis, and Daoist transformation exhibit similar phenomenological structures?
- What are the unique intentional correlates in each tradition's approach to consciousness?
- How do different traditions approach the relationship between ego-dissolution and awakening?

Synthesize insights into a unified phenomenology of contemplative transformation.`
      },

      meta_ontological: {
        name: "Meta-Ontological Synthesis",
        description: "Fundamental reality analysis across traditions",
        template: `Analyze the ontological foundations underlying: {elements}

**Meta-Ontological Investigation:**
1. **Being vs. Becoming**: Static essence vs. dynamic process orientations
2. **Unity vs. Multiplicity**: How each tradition resolves the one-many problem
3. **Causation Models**: Linear, circular, emanative, or non-causal frameworks
4. **Substance vs. Process**: Fundamental reality as entity or activity
5. **Transcendence vs. Immanence**: Location of ultimate reality

**Tradition-Specific Ontologies:**
- Buddhist: Dependent origination and emptiness of inherent existence
- Alchemical: Correspondence between microcosm and macrocosm
- Kabbalistic: Emanationist hierarchy from Ein Sof to material reality
- Vedantic: Non-dual Brahman appearing as apparent multiplicity
- Daoist: Wu Wei and the spontaneous flow of natural process

Construct a meta-ontology that encompasses these diverse approaches to fundamental reality.`
      },

      archetypal_psychology: {
        name: "Archetypal Psychology",
        description: "Jungian depth psychology synthesis",
        template: `Examine through archetypal psychology framework: {elements}

**Archetypal Analysis:**
1. **Collective Unconscious**: Universal patterns across contemplative traditions
2. **Individuation Process**: How each tradition facilitates psychological wholeness
3. **Shadow Integration**: Methods for incorporating rejected aspects of psyche
4. **Anima/Animus**: Contrasexual dynamics in spiritual development
5. **Transcendent Function**: Synthesis of conscious and unconscious contents

**Cross-Traditional Archetypes:**
- The Wise Old Man/Woman appearing across traditions
- Death-Rebirth cycles in Buddhist bardo, alchemical nigredo, Kabbalistic tzimtzum
- Divine Child emergence in awakened consciousness
- Syzygy and sacred marriage motifs

How do these contemplative stages activate archetypal energies and facilitate psychological transformation? Compare with dreams, active imagination, and depth therapeutic processes.`
      },

      systems_emergence: {
        name: "Systems & Emergence",
        description: "Complex systems analysis of contemplative development",
        template: `Analyze as complex adaptive systems: {elements}

**Systems Framework:**
1. **Emergence**: How higher-order properties arise from contemplative practice
2. **Self-Organization**: Spontaneous pattern formation in consciousness
3. **Critical Transitions**: Phase changes and tipping points in development
4. **Feedback Loops**: Positive and negative feedback in contemplative systems
5. **Network Topology**: Connection patterns between contemplative stages

**Emergence Analysis:**
- Buddhist dependent origination as circular causality system
- Alchemical operations as chemical reaction networks
- Kabbalistic Tree as hierarchical emergence topology
- Vedantic koshas as nested systems architecture
- Daoist transformations as dynamic equilibrium systems

Model contemplative development as complex adaptive system with emergent properties, self-organization, and critical phase transitions.`
      },

      linguistic_philosophy: {
        name: "Linguistic Philosophy",
        description: "Language games and meaning analysis",
        template: `Examine through linguistic philosophy: {elements}

**Linguistic Analysis:**
1. **Language Games**: How each tradition creates unique meaning contexts
2. **Speech Acts**: Performative aspects of contemplative discourse
3. **Metaphor Theory**: Conceptual metaphors structuring contemplative understanding
4. **Semantic Fields**: Networks of meaning within contemplative vocabularies
5. **Translation Problems**: Incommensurability across contemplative languages

**Tradition-Specific Language Games:**
- Buddhist technical terminology and precise phenomenological description
- Alchemical symbolic language and hermetic codes
- Kabbalistic gematria and mystical hermeneutics
- Vedantic Sanskrit conceptual precision
- Daoist paradoxical and poetic expression

How do different contemplative traditions create meaning through language? What gets lost or gained in cross-traditional translation? Analyze the relationship between linguistic expression and contemplative insight.`
      },

      enactive_cognition: {
        name: "Enactive Cognition",
        description: "4E cognition and embodied mind analysis",
        template: `Analyze through enactive cognition framework: {elements}

**4E Cognition Analysis:**
1. **Embodied**: Role of body and posture in contemplative practice
2. **Embedded**: Environmental factors shaping contemplative development
3. **Extended**: How tools and techniques extend contemplative cognition
4. **Enacted**: How contemplatives enact their reality through practice

**Enactive Processes:**
- Structural coupling between practitioner and contemplative environment
- Autopoietic maintenance of contemplative identity
- Sensorimotor contingencies in meditative awareness
- Participatory knowing and co-emergence with reality

How do these contemplative stages involve enacted perception and embodied meaning-making? Compare Buddhist mindfulness, alchemical laboratory work, Kabbalistic visualization, Vedantic self-inquiry, and Daoist movement practices as forms of enactive cognition.`
      },

      quantum_consciousness: {
        name: "Quantum Consciousness",
        description: "Quantum mechanics and consciousness interface",
        template: `Explore quantum mechanical parallels: {elements}

**Quantum Framework:**
1. **Superposition**: Multiple contemplative states existing simultaneously
2. **Entanglement**: Non-local correlations between contemplative phenomena
3. **Measurement**: How contemplative observation affects reality
4. **Complementarity**: Wave-particle duality in consciousness studies
5. **Decoherence**: How environment affects contemplative coherence

**Quantum Contemplative Parallels:**
- Buddhist emptiness and quantum vacuum fluctuations
- Alchemical transmutation and quantum state transitions
- Kabbalistic tzimtzum and wave function collapse
- Vedantic non-duality and quantum entanglement
- Daoist wu wei and quantum indeterminacy

Model contemplative consciousness using quantum information theory, geometric phases, and many-worlds interpretation. How might contemplative practices interface with quantum processes in microtubules or other biological quantum systems?`
      }
    };

    // Chemical Computing Aquarium Application
    class ChemicalComputingAquarium {
      constructor() {
        this.state = {
          currentTradition: 'buddhist',
          floatingNodes: [],
          connections: [],
          synthesisOperations: [],
          selectedTemplate: 'comparative_phenomenology',
          physics: {
            enabled: true,
            gravity: 0.1,
            friction: 0.95,
            attraction: 50,
            repulsion: 30
          },
          api: {
            key: '',
            model: 'openai/gpt-4o',
            temperature: 0.7,
            maxTokens: 1200,
            isLoading: false,
            controller: null
          },
          dragState: null,
          aquariumBounds: { width: 0, height: 0 }
        };

        this.elements = {
          traditionStages: document.getElementById('tradition-stages'),
          aquariumContainer: document.getElementById('aquarium-container'),
          templateGrid: document.getElementById('template-grid'),
          synthesisOperations: document.getElementById('synthesis-operations'),
          promptInput: document.getElementById('prompt-input'),
          responseArea: document.getElementById('response-area'),
          notification: document.getElementById('notification'),
          notificationText: document.getElementById('notification-text')
        };

        this.animationId = null;

        this.initializeAquarium();
        this.setupInterface();
        this.setupEventListeners();
        this.startPhysicsLoop();

        this.showNotification('Chemical Computing Aquarium initialized - drag contemplative elements to synthesize', 'success');
      }

      initializeAquarium() {
        // Set aquarium bounds
        const rect = this.elements.aquariumContainer.getBoundingClientRect();
        this.state.aquariumBounds = { width: rect.width, height: rect.height };

        // Initialize with some random nodes for demonstration
        this.addRandomNodes();
      }

      addRandomNodes() {
        const traditions = ['buddhist', 'alchemical', 'kabbalistic'];
        const data = {
          buddhist: BUDDHIST_NIDANAS,
          alchemical: ALCHEMICAL_OPERATIONS,
          kabbalistic: KABBALISTIC_SEPHIROT
        };

        traditions.forEach((tradition, traditionIndex) => {
          const elements = data[tradition];
          for (let i = 0; i < 3; i++) {
            const element = elements[Math.floor(Math.random() * elements.length)];
            this.addFloatingNode(element, tradition, {
              x: 100 + traditionIndex * 200 + Math.random() * 100,
              y: 100 + i * 150 + Math.random() * 50
            });
          }
        });
      }

      addFloatingNode(element, tradition, position = null) {
        if (!position) {
          position = {
            x: Math.random() * (this.state.aquariumBounds.width - 100) + 50,
            y: Math.random() * (this.state.aquariumBounds.height - 100) + 50
          };
        }

        const node = {
          id: `${tradition}-${element.id}-${Date.now()}`,
          element: element,
          tradition: tradition,
          position: position,
          velocity: { x: 0, y: 0 },
          force: { x: 0, y: 0 },
          connections: [],
          selected: false,
          dragging: false
        };

        this.state.floatingNodes.push(node);
        this.renderFloatingNode(node);
        this.updateMetrics();
        
        return node;
      }

      renderFloatingNode(node) {
        const nodeEl = document.createElement('div');
        nodeEl.className = `floating-node ${node.tradition}-node`;
        nodeEl.id = node.id;
        nodeEl.style.left = `${node.position.x}px`;
        nodeEl.style.top = `${node.position.y}px`;
        nodeEl.style.borderColor = node.element.color;
        nodeEl.style.backgroundColor = `${node.element.color}20`;

        const symbolEl = document.createElement('div');
        symbolEl.className = 'node-symbol';
        
        switch (node.tradition) {
          case 'buddhist':
            symbolEl.textContent = node.element.chinese;
            break;
          case 'alchemical':
            symbolEl.textContent = node.element.symbol;
            break;
          case 'kabbalistic':
            symbolEl.textContent = node.element.name;
            symbolEl.style.fontSize = '0.8rem';
            break;
          case 'vedantic':
            symbolEl.textContent = node.element.name.substring(0, 2);
            break;
          case 'daoist':
            symbolEl.textContent = node.element.name;
            break;
        }

        nodeEl.appendChild(symbolEl);

        // Add tooltip
        nodeEl.title = `${node.element.english || node.element.name}: ${node.element.description}`;

        // Add event listeners
        nodeEl.addEventListener('mousedown', (e) => this.startDrag(e, node));
        nodeEl.addEventListener('click', (e) => this.selectNode(e, node));

        this.elements.aquariumContainer.appendChild(nodeEl);
      }

      startDrag(e, node) {
        e.preventDefault();
        this.state.dragState = {
          node: node,
          startX: e.clientX,
          startY: e.clientY,
          startNodeX: node.position.x,
          startNodeY: node.position.y
        };

        node.dragging = true;
        document.getElementById(node.id).classList.add('dragging');

        document.addEventListener('mousemove', this.handleDrag.bind(this));
        document.addEventListener('mouseup', this.endDrag.bind(this));
      }

      handleDrag(e) {
        if (!this.state.dragState) return;

        const { node, startX, startY, startNodeX, startNodeY } = this.state.dragState;
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;

        node.position.x = Math.max(30, Math.min(this.state.aquariumBounds.width - 30, startNodeX + deltaX));
        node.position.y = Math.max(30, Math.min(this.state.aquariumBounds.height - 30, startNodeY + deltaY));

        this.updateNodePosition(node);

        // Check for potential snap targets
        this.checkSnapTargets(node);
      }

      endDrag(e) {
        if (!this.state.dragState) return;

        const draggedNode = this.state.dragState.node;
        draggedNode.dragging = false;
        document.getElementById(draggedNode.id).classList.remove('dragging');

        // Check for snap to other nodes
        const snapTarget = this.findSnapTarget(draggedNode);
        if (snapTarget) {
          this.createSynthesisOperation(draggedNode, snapTarget);
        }

        this.state.dragState = null;
        document.removeEventListener('mousemove', this.handleDrag.bind(this));
        document.removeEventListener('mouseup', this.endDrag.bind(this));
      }

      findSnapTarget(node) {
        const snapDistance = 80;
        
        return this.state.floatingNodes.find(otherNode => {
          if (otherNode.id === node.id) return false;
          
          const distance = Math.sqrt(
            Math.pow(node.position.x - otherNode.position.x, 2) +
            Math.pow(node.position.y - otherNode.position.y, 2)
          );
          
          return distance < snapDistance;
        });
      }

      createSynthesisOperation(node1, node2) {
        // Snap nodes together
        const midX = (node1.position.x + node2.position.x) / 2;
        const midY = (node1.position.y + node2.position.y) / 2;
        
        node1.position.x = midX - 40;
        node1.position.y = midY;
        node2.position.x = midX + 40;
        node2.position.y = midY;
        
        this.updateNodePosition(node1);
        this.updateNodePosition(node2);

        // Add snapping animation
        document.getElementById(node1.id).classList.add('snapping');
        document.getElementById(node2.id).classList.add('snapping');
        
        setTimeout(() => {
          document.getElementById(node1.id).classList.remove('snapping');
          document.getElementById(node2.id).classList.remove('snapping');
        }, 500);

        // Create synthesis operation
        const operation = {
          id: `synthesis-${Date.now()}`,
          nodes: [node1, node2],
          type: this.determineSynthesisType(node1, node2),
          promptFragment: this.generateSynthesisPrompt(node1, node2)
        };

        this.state.synthesisOperations.push(operation);
        this.createConnection(node1, node2);
        this.updateSynthesisOperations();
        this.updatePrompt();
        this.updateMetrics();

        this.showNotification(`Synthesis created: ${operation.type}`, 'success');
      }

      determineSynthesisType(node1, node2) {
        const traditions = [node1.tradition, node2.tradition].sort();
        const traditionsKey = traditions.join('-');

        const typeMap = {
          'alchemical-buddhist': 'Transformational Correspondence',
          'buddhist-kabbalistic': 'Emanational Interdependence', 
          'alchemical-kabbalistic': 'Hermetic Synthesis',
          'buddhist-vedantic': 'Non-Dual Awareness',
          'buddhist-daoist': 'Spontaneous Awakening',
          'alchemical-vedantic': 'Conscious Transmutation',
          'alchemical-daoist': 'Natural Alchemy',
          'kabbalistic-vedantic': 'Divine Self-Realization',
          'kabbalistic-daoist': 'Mystical Spontaneity',
          'daoist-vedantic': 'Effortless Being'
        };

        return typeMap[traditionsKey] || 'Cross-Traditional Synthesis';
      }

      generateSynthesisPrompt(node1, node2) {
        const fragment1 = node1.element.promptFragment;
        const fragment2 = node2.element.promptFragment;
        
        return `synthesis of ${fragment1} with ${fragment2}, exploring their mutual correspondence and emergent properties`;
      }

      createConnection(node1, node2) {
        const connection = {
          id: `connection-${Date.now()}`,
          from: node1.id,
          to: node2.id,
          strength: this.calculateConnectionStrength(node1, node2)
        };

        this.state.connections.push(connection);
        this.renderConnection(connection);
      }

      calculateConnectionStrength(node1, node2) {
        // Calculate based on semantic similarity and tradition compatibility
        const traditionCompatibility = {
          'buddhist-alchemical': 0.8,
          'buddhist-kabbalistic': 0.7,
          'alchemical-kabbalistic': 0.9,
          'buddhist-vedantic': 0.9,
          'buddhist-daoist': 0.8,
          'alchemical-vedantic': 0.7,
          'alchemical-daoist': 0.8,
          'kabbalistic-vedantic': 0.6,
          'kabbalistic-daoist': 0.5,
          'vedantic-daoist': 0.7
        };

        const traditions = [node1.tradition, node2.tradition].sort().join('-');
        return traditionCompatibility[traditions] || 0.5;
      }

      renderConnection(connection) {
        const fromNode = this.state.floatingNodes.find(n => n.id === connection.from);
        const toNode = this.state.floatingNodes.find(n => n.id === connection.to);
        
        if (!fromNode || !toNode) return;

        const line = document.createElement('div');
        line.className = 'connection-line';
        line.id = connection.id;

        this.updateConnectionPosition(connection, line, fromNode, toNode);
        this.elements.aquariumContainer.appendChild(line);
      }

      updateConnectionPosition(connection, lineEl, fromNode, toNode) {
        const dx = toNode.position.x - fromNode.position.x;
        const dy = toNode.position.y - fromNode.position.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;

        lineEl.style.left = `${fromNode.position.x + 30}px`;
        lineEl.style.top = `${fromNode.position.y + 30}px`;
        lineEl.style.width = `${length}px`;
        lineEl.style.transform = `rotate(${angle}deg)`;
        lineEl.style.opacity = connection.strength;
      }

      updateNodePosition(node) {
        const nodeEl = document.getElementById(node.id);
        if (nodeEl) {
          nodeEl.style.left = `${node.position.x}px`;
          nodeEl.style.top = `${node.position.y}px`;
        }

        // Update connections
        this.state.connections.forEach(connection => {
          if (connection.from === node.id || connection.to === node.id) {
            const lineEl = document.getElementById(connection.id);
            const fromNode = this.state.floatingNodes.find(n => n.id === connection.from);
            const toNode = this.state.floatingNodes.find(n => n.id === connection.to);
            
            if (lineEl && fromNode && toNode) {
              this.updateConnectionPosition(connection, lineEl, fromNode, toNode);
            }
          }
        });
      }

      checkSnapTargets(draggedNode) {
        this.state.floatingNodes.forEach(node => {
          if (node.id === draggedNode.id) return;
          
          const distance = Math.sqrt(
            Math.pow(draggedNode.position.x - node.position.x, 2) +
            Math.pow(draggedNode.position.y - node.position.y, 2)
          );
          
          const nodeEl = document.getElementById(node.id);
          if (distance < 80) {
            nodeEl.style.boxShadow = '0 0 30px var(--success-color)';
          } else {
            nodeEl.style.boxShadow = '';
          }
        });
      }

      selectNode(e, node) {
        if (e.shiftKey) {
          node.selected = !node.selected;
          document.getElementById(node.id).classList.toggle('selected', node.selected);
        }
      }

      startPhysicsLoop() {
        if (!this.state.physics.enabled) return;

        const animate = () => {
          this.updatePhysics();
          this.animationId = requestAnimationFrame(animate);
        };
        
        animate();
      }

      updatePhysics() {
        if (!this.state.physics.enabled) return;

        this.state.floatingNodes.forEach(node => {
          if (node.dragging) return;

          // Reset forces
          node.force = { x: 0, y: 0 };

          // Apply gravity toward center
          const centerX = this.state.aquariumBounds.width / 2;
          const centerY = this.state.aquariumBounds.height / 2;
          const toCenterX = centerX - node.position.x;
          const toCenterY = centerY - node.position.y;
          
          node.force.x += toCenterX * this.state.physics.gravity * 0.001;
          node.force.y += toCenterY * this.state.physics.gravity * 0.001;

          // Apply inter-node forces
          this.state.floatingNodes.forEach(otherNode => {
            if (node.id === otherNode.id) return;

            const dx = otherNode.position.x - node.position.x;
            const dy = otherNode.position.y - node.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 100) {
              // Repulsion at close range
              const repulsion = this.state.physics.repulsion / (distance * distance);
              node.force.x -= (dx / distance) * repulsion;
              node.force.y -= (dy / distance) * repulsion;
            }

            // Attraction for connected nodes
            const isConnected = this.state.connections.some(conn => 
              (conn.from === node.id && conn.to === otherNode.id) ||
              (conn.to === node.id && conn.from === otherNode.id)
            );

            if (isConnected && distance > 80) {
              const attraction = this.state.physics.attraction / distance;
              node.force.x += (dx / distance) * attraction * 0.01;
              node.force.y += (dy / distance) * attraction * 0.01;
            }
          });

          // Update velocity and position
          node.velocity.x += node.force.x;
          node.velocity.y += node.force.y;
          node.velocity.x *= this.state.physics.friction;
          node.velocity.y *= this.state.physics.friction;

          node.position.x += node.velocity.x;
          node.position.y += node.velocity.y;

          // Boundary conditions
          if (node.position.x < 30) {
            node.position.x = 30;
            node.velocity.x *= -0.5;
          }
          if (node.position.x > this.state.aquariumBounds.width - 30) {
            node.position.x = this.state.aquariumBounds.width - 30;
            node.velocity.x *= -0.5;
          }
          if (node.position.y < 30) {
            node.position.y = 30;
            node.velocity.y *= -0.5;
          }
          if (node.position.y > this.state.aquariumBounds.height - 30) {
            node.position.y = this.state.aquariumBounds.height - 30;
            node.velocity.y *= -0.5;
          }

          this.updateNodePosition(node);
        });
      }

      setupInterface() {
        this.renderTraditionStages();
        this.renderTemplates();
        this.updatePrompt();
      }

      renderTraditionStages() {
        const traditions = {
          buddhist: BUDDHIST_NIDANAS,
          alchemical: ALCHEMICAL_OPERATIONS,
          kabbalistic: KABBALISTIC_SEPHIROT,
          vedantic: VEDANTIC_STAGES,
          daoist: DAOIST_TRANSFORMATIONS
        };

        const data = traditions[this.state.currentTradition];
        
        this.elements.traditionStages.innerHTML = data.map(item => {
          const inAquarium = this.state.floatingNodes.some(node => 
            node.tradition === this.state.currentTradition && node.element.id === item.id
          );

          return `
            <div class="stage-card ${inAquarium ? 'in-aquarium' : ''}" 
                 data-tradition="${this.state.currentTradition}" 
                 data-id="${item.id}"
                 draggable="true">
              <div class="stage-header">
                <div class="stage-number">${item.number}</div>
                <div class="stage-symbol">${this.getSymbol(item, this.state.currentTradition)}</div>
                <div class="stage-info">
                  <div class="stage-name">${item.english || item.name}</div>
                  <div class="stage-transliteration">${item.transliteration || item.latin || ''}</div>
                </div>
              </div>
              <div class="stage-description">${item.description}</div>
              <div class="prompt-fragment">${item.promptFragment}</div>
            </div>
          `;
        }).join('');

        this.updateMetrics();
      }

      getSymbol(item, tradition) {
        switch (tradition) {
          case 'buddhist': return item.chinese;
          case 'alchemical': return item.symbol;
          case 'kabbalistic': return item.name;
          case 'vedantic': return item.name.substring(0, 3);
          case 'daoist': return item.name;
          default: return item.name?.substring(0, 2) || '?';
        }
      }

      renderTemplates() {
        this.elements.templateGrid.innerHTML = Object.entries(SYNTHESIS_TEMPLATES).map(([key, template]) => `
          <div class="template-card ${key === this.state.selectedTemplate ? 'active' : ''}" data-template="${key}">
            <div class="template-name">${template.name}</div>
            <div class="template-description">${template.description}</div>
          </div>
        `).join('');
      }

      updateSynthesisOperations() {
        if (this.state.synthesisOperations.length === 0) {
          this.elements.synthesisOperations.innerHTML = 
            '<em style="color: var(--text-muted);">Drag nodes together to create synthesis operations</em>';
        } else {
          this.elements.synthesisOperations.innerHTML = this.state.synthesisOperations.map((operation, index) => `
            <span class="operation-tag">
              ${operation.type}
              <span class="tag-remove" onclick="app.removeSynthesisOperation(${index})">×</span>
            </span>
          `).join('');
        }
      }

      removeSynthesisOperation(index) {
        const operation = this.state.synthesisOperations[index];
        
        // Remove connection
        const connectionIndex = this.state.connections.findIndex(conn => 
          operation.nodes.some(node => conn.from === node.id || conn.to === node.id)
        );
        
        if (connectionIndex !== -1) {
          const connection = this.state.connections[connectionIndex];
          const lineEl = document.getElementById(connection.id);
          if (lineEl) lineEl.remove();
          this.state.connections.splice(connectionIndex, 1);
        }

        this.state.synthesisOperations.splice(index, 1);
        this.updateSynthesisOperations();
        this.updatePrompt();
        this.updateMetrics();
      }

      updatePrompt() {
        const template = SYNTHESIS_TEMPLATES[this.state.selectedTemplate];
        
        if (this.state.synthesisOperations.length > 0) {
          const elementsText = this.state.synthesisOperations.map(op => 
            `${op.promptFragment}`
          ).join('\n\n');
          
          this.elements.promptInput.value = template.template.replace('{elements}', elementsText);
        } else {
          this.elements.promptInput.value = template.template.replace(
            '{elements}', 
            '[Drag contemplative elements together in the aquarium to create synthesis operations]'
          );
        }
      }

      updateMetrics() {
        const traditions = {
          buddhist: BUDDHIST_NIDANAS.length,
          alchemical: ALCHEMICAL_OPERATIONS.length,
          kabbalistic: KABBALISTIC_SEPHIROT.length,
          vedantic: VEDANTIC_STAGES.length,
          daoist: DAOIST_TRANSFORMATIONS.length
        };

        document.getElementById('tradition-elements').textContent = traditions[this.state.currentTradition];
        document.getElementById('aquarium-count').textContent = this.state.floatingNodes.length;
        document.getElementById('active-bonds').textContent = this.state.connections.length;
        document.getElementById('synthesis-operations').textContent = this.state.synthesisOperations.length;
      }

      setupEventListeners() {
        // Tradition selector
        document.querySelectorAll('.tradition-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            document.querySelectorAll('.tradition-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            this.state.currentTradition = btn.dataset.tradition;
            this.renderTraditionStages();
          });
        });

        // Template selection
        this.elements.templateGrid.addEventListener('click', (e) => {
          const card = e.target.closest('.template-card');
          if (card) {
            document.querySelectorAll('.template-card').forEach(c => c.classList.remove('active'));
            card.classList.add('active');
            this.state.selectedTemplate = card.dataset.template;
            this.updatePrompt();
          }
        });

        // Drag from tradition panel to aquarium
        this.elements.traditionStages.addEventListener('dragstart', (e) => {
          const card = e.target.closest('.stage-card');
          if (card) {
            const tradition = card.dataset.tradition;
            const id = card.dataset.id;
            e.dataTransfer.setData('text/plain', JSON.stringify({ tradition, id }));
          }
        });

        this.elements.aquariumContainer.addEventListener('dragover', (e) => {
          e.preventDefault();
        });

        this.elements.aquariumContainer.addEventListener('drop', (e) => {
          e.preventDefault();
          
          try {
            const data = JSON.parse(e.dataTransfer.getData('text/plain'));
            const traditions = {
              buddhist: BUDDHIST_NIDANAS,
              alchemical: ALCHEMICAL_OPERATIONS,
              kabbalistic: KABBALISTIC_SEPHIROT,
              vedantic: VEDANTIC_STAGES,
              daoist: DAOIST_TRANSFORMATIONS
            };
            
            const element = traditions[data.tradition].find(e => e.id === data.id);
            if (element) {
              const rect = this.elements.aquariumContainer.getBoundingClientRect();
              const position = {
                x: e.clientX - rect.left - 30,
                y: e.clientY - rect.top - 30
              };
              
              this.addFloatingNode(element, data.tradition, position);
              this.renderTraditionStages(); // Update the panel to show node is in aquarium
            }
          } catch (error) {
            console.warn('Drop failed:', error);
          }
        });

        // Aquarium controls
        document.getElementById('reset-aquarium').addEventListener('click', () => {
          this.resetAquarium();
        });

        document.getElementById('animate-physics').addEventListener('click', () => {
          this.state.physics.enabled = !this.state.physics.enabled;
          const btn = document.getElementById('animate-physics');
          btn.classList.toggle('active', this.state.physics.enabled);
          
          if (this.state.physics.enabled) {
            this.startPhysicsLoop();
          } else {
            if (this.animationId) {
              cancelAnimationFrame(this.animationId);
            }
          }
        });

        document.getElementById('clear-all').addEventListener('click', () => {
          this.clearAll();
        });

        // API controls
        document.getElementById('send-request').addEventListener('click', () => this.sendRequest());
        document.getElementById('cancel-request').addEventListener('click', () => this.cancelRequest());

        // Settings
        document.getElementById('temperature-range').addEventListener('input', (e) => {
          this.state.api.temperature = parseFloat(e.target.value);
          document.getElementById('temperature-value').textContent = e.target.value;
        });

        document.getElementById('tokens-range').addEventListener('input', (e) => {
          this.state.api.maxTokens = parseInt(e.target.value);
          document.getElementById('tokens-value').textContent = e.target.value;
        });

        document.getElementById('model-select').addEventListener('change', (e) => {
          this.state.api.model = e.target.value;
        });

        // Window resize
        window.addEventListener('resize', () => this.onWindowResize());

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          if (e.ctrlKey && e.key === 'Enter') {
            e.preventDefault();
            if (!this.state.api.isLoading) this.sendRequest();
          }
          
          if (e.key === 'Escape') {
            this.clearSelection();
          }

          // Tradition shortcuts (1-5)
          if (e.key >= '1' && e.key <= '5') {
            const traditions = ['buddhist', 'alchemical', 'kabbalistic', 'vedantic', 'daoist'];
            const index = parseInt(e.key) - 1;
            if (traditions[index]) {
              this.state.currentTradition = traditions[index];
              document.querySelectorAll('.tradition-btn').forEach((btn, i) => {
                btn.classList.toggle('active', i === index);
              });
              this.renderTraditionStages();
            }
          }

          // Physics toggle (Space)
          if (e.key === ' ') {
            e.preventDefault();
            document.getElementById('animate-physics').click();
          }

          // Clear all (C)
          if (e.key === 'c') {
            this.clearAll();
          }

          // Reset aquarium (R)
          if (e.key === 'r') {
            this.resetAquarium();
          }
        });
      }

      resetAquarium() {
        this.clearAll();
        this.addRandomNodes();
        this.showNotification('Aquarium reset with random nodes', 'success');
      }

      clearAll() {
        // Remove all floating nodes
        this.state.floatingNodes.forEach(node => {
          const nodeEl = document.getElementById(node.id);
          if (nodeEl) nodeEl.remove();
        });

        // Remove all connections
        this.state.connections.forEach(connection => {
          const lineEl = document.getElementById(connection.id);
          if (lineEl) lineEl.remove();
        });

        this.state.floatingNodes = [];
        this.state.connections = [];
        this.state.synthesisOperations = [];

        this.updateSynthesisOperations();
        this.updatePrompt();
        this.updateMetrics();
        this.renderTraditionStages();
      }

      clearSelection() {
        this.state.floatingNodes.forEach(node => {
          node.selected = false;
          const nodeEl = document.getElementById(node.id);
          if (nodeEl) {
            nodeEl.classList.remove('selected');
            nodeEl.style.boxShadow = '';
          }
        });
      }

      onWindowResize() {
        const rect = this.elements.aquariumContainer.getBoundingClientRect();
        this.state.aquariumBounds = { width: rect.width, height: rect.height };
        
        // Adjust node positions if they're outside new bounds
        this.state.floatingNodes.forEach(node => {
          node.position.x = Math.min(node.position.x, this.state.aquariumBounds.width - 60);
          node.position.y = Math.min(node.position.y, this.state.aquariumBounds.height - 60);
          this.updateNodePosition(node);
        });
      }

      async sendRequest() {
        const prompt = this.elements.promptInput.value.trim();
        if (!prompt) {
          this.showNotification('Please construct a synthesis prompt by dragging elements together', 'error');
          return;
        }

        this.state.api.isLoading = true;
        document.getElementById('send-request').disabled = true;
        document.getElementById('cancel-request').style.display = 'inline-block';
        document.getElementById('loading-spinner').style.display = 'inline-block';
        this.elements.responseArea.textContent = '';

        const controller = new AbortController();
        this.state.api.controller = controller;

        try {
          const response = await fetch('/api/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${this.state.api.key}`,
              'Content-Type': 'application/json',
              'HTTP-Referer': window.location.origin,
              'X-Title': 'Chemical Computing Aquarium'
            },
            body: JSON.stringify({
              model: this.state.api.model,
              messages: [{ role: 'user', content: prompt }],
              temperature: this.state.api.temperature,
              max_tokens: this.state.api.maxTokens,
              stream: true
            }),
            signal: controller.signal
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error?.message || `HTTP ${response.status}`);
          }

          await this.handleStreamingResponse(response);
          this.showNotification('Multi-tradition synthesis completed', 'success');

        } catch (error) {
          if (error.name !== 'AbortError') {
            this.showNotification(`Error: ${error.message}`, 'error');
            console.error('Request failed:', error);
          }
        } finally {
          this.state.api.isLoading = false;
          document.getElementById('send-request').disabled = false;
          document.getElementById('cancel-request').style.display = 'none';
          document.getElementById('loading-spinner').style.display = 'none';
        }
      }

      async handleStreamingResponse(response) {
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let fullText = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });

          while (true) {
            const lineEnd = buffer.indexOf('\n');
            if (lineEnd === -1) break;
            const line = buffer.slice(0, lineEnd).trim();
            buffer = buffer.slice(lineEnd + 1);

            if (line.startsWith('data: ')) {
              const data = line.slice(6);
              if (data === '[DONE]') break;

              try {
                const parsed = JSON.parse(data);
                const content = parsed.choices[0].delta.content;
                if (content) {
                  fullText += content;
                  this.elements.responseArea.textContent = fullText;
                  this.elements.responseArea.scrollTop = this.elements.responseArea.scrollHeight;
                }
              } catch (e) {
                // Ignore invalid JSON
              }
            }
          }
        }
      }

      cancelRequest() {
        if (this.state.api.controller) {
          this.state.api.controller.abort();
          this.showNotification('Request cancelled', 'warning');
        }
      }

      showNotification(message, type = 'success', duration = 4000) {
        this.elements.notification.className = `notification ${type}`;
        this.elements.notificationText.textContent = message;
        this.elements.notification.style.display = 'block';

        setTimeout(() => {
          this.elements.notification.style.display = 'none';
        }, duration);
      }

      // Export functionality
      exportAquariumState() {
        const exportData = {
          timestamp: new Date().toISOString(),
          floatingNodes: this.state.floatingNodes.map(node => ({
            element: node.element,
            tradition: node.tradition,
            position: node.position
          })),
          connections: this.state.connections,
          synthesisOperations: this.state.synthesisOperations,
          selectedTemplate: this.state.selectedTemplate
        };

        const blob = new Blob([JSON.stringify(exportData, null, 2)], 
                            { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `chemical-aquarium-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);

        this.showNotification('Aquarium state exported successfully', 'success');
      }

      // Advanced interaction methods
      createSynthesisCluster() {
        const selectedNodes = this.state.floatingNodes.filter(node => node.selected);
        if (selectedNodes.length < 2) {
          this.showNotification('Select at least 2 nodes to create a synthesis cluster', 'warning');
          return;
        }

        // Calculate cluster center
        const centerX = selectedNodes.reduce((sum, node) => sum + node.position.x, 0) / selectedNodes.length;
        const centerY = selectedNodes.reduce((sum, node) => sum + node.position.y, 0) / selectedNodes.length;

        // Create cluster element
        const cluster = document.createElement('div');
        cluster.className = 'synthesis-cluster';
        cluster.style.left = `${centerX - 75}px`;
        cluster.style.top = `${centerY - 75}px`;

        const label = document.createElement('div');
        label.className = 'cluster-label';
        label.textContent = `Synthesis Cluster (${selectedNodes.length} nodes)`;
        cluster.appendChild(label);

        this.elements.aquariumContainer.appendChild(cluster);

        // Arrange nodes in circle around cluster
        selectedNodes.forEach((node, index) => {
          const angle = (index / selectedNodes.length) * Math.PI * 2;
          const radius = 60;
          node.position.x = centerX + Math.cos(angle) * radius;
          node.position.y = centerY + Math.sin(angle) * radius;
          this.updateNodePosition(node);
        });

        // Create connections between all nodes in cluster
        for (let i = 0; i < selectedNodes.length; i++) {
          for (let j = i + 1; j < selectedNodes.length; j++) {
            this.createConnection(selectedNodes[i], selectedNodes[j]);
          }
        }

        this.clearSelection();
        this.showNotification(`Created synthesis cluster with ${selectedNodes.length} nodes`, 'success');
      }

      // Advanced chemistry simulation
      simulateChemicalReaction() {
        // Find clusters of connected nodes
        const clusters = this.findClusters();
        
        clusters.forEach(cluster => {
          if (cluster.length >= 3) {
            // Simulate reaction: create new emergent properties
            const emergentNode = this.createEmergentNode(cluster);
            if (emergentNode) {
              this.showNotification(`Chemical reaction produced emergent synthesis: ${emergentNode.element.english}`, 'success');
            }
          }
        });
      }

      findClusters() {
        const visited = new Set();
        const clusters = [];

        this.state.floatingNodes.forEach(node => {
          if (!visited.has(node.id)) {
            const cluster = [];
            this.dfsCluster(node, visited, cluster);
            if (cluster.length > 1) {
              clusters.push(cluster);
            }
          }
        });

        return clusters;
      }

      dfsCluster(node, visited, cluster) {
        visited.add(node.id);
        cluster.push(node);

        this.state.connections.forEach(connection => {
          let otherNodeId = null;
          if (connection.from === node.id) {
            otherNodeId = connection.to;
          } else if (connection.to === node.id) {
            otherNodeId = connection.from;
          }

          if (otherNodeId && !visited.has(otherNodeId)) {
            const otherNode = this.state.floatingNodes.find(n => n.id === otherNodeId);
            if (otherNode) {
              this.dfsCluster(otherNode, visited, cluster);
            }
          }
        });
      }

      createEmergentNode(cluster) {
        // Create synthetic element from cluster properties
        const traditions = [...new Set(cluster.map(node => node.tradition))];
        const categories = [...new Set(cluster.map(node => node.element.category))];
        
        const emergentElement = {
          id: `emergent-${Date.now()}`,
          number: 0,
          name: `Emergent Synthesis`,
          english: `${traditions.join('-')} Emergence`,
          description: `Emergent synthesis arising from interaction of ${cluster.length} contemplative elements`,
          category: 'Emergent',
          color: this.blendColors(cluster.map(node => node.element.color)),
          weight: Math.round(cluster.reduce((sum, node) => sum + node.element.weight, 0) / cluster.length),
          promptFragment: `emergent synthesis integrating ${cluster.map(node => node.element.english || node.element.name).join(', ')}`
        };

        // Position at cluster center
        const centerX = cluster.reduce((sum, node) => sum + node.position.x, 0) / cluster.length;
        const centerY = cluster.reduce((sum, node) => sum + node.position.y, 0) / cluster.length;

        return this.addFloatingNode(emergentElement, 'emergent', { x: centerX, y: centerY });
      }

      blendColors(colors) {
        // Simple color blending - average RGB values
        const rgbColors = colors.map(color => {
          const hex = color.replace('#', '');
          return [
            parseInt(hex.substr(0, 2), 16),
            parseInt(hex.substr(2, 2), 16),
            parseInt(hex.substr(4, 2), 16)
          ];
        });

        const avgColor = rgbColors.reduce((acc, rgb) => [
          acc[0] + rgb[0],
          acc[1] + rgb[1],
          acc[2] + rgb[2]
        ], [0, 0, 0]).map(channel => Math.round(channel / colors.length));

        return `#${avgColor.map(c => c.toString(16).padStart(2, '0')).join('')}`;
      }
    }

    // Global reference for event handlers
    let app;

    // Initialize application when DOM loads
    document.addEventListener('DOMContentLoaded', () => {
      app = new ChemicalComputingAquarium();
      
      // Add export button to aquarium
      const exportBtn = document.createElement('button');
      exportBtn.textContent = 'Export State';
      exportBtn.className = 'control-button';
      exportBtn.style.position = 'absolute';
      exportBtn.style.bottom = '1rem';
      exportBtn.style.right = '1rem';
      exportBtn.style.zIndex = '50';
      exportBtn.onclick = () => app.exportAquariumState();
      document.querySelector('.aquarium-canvas').appendChild(exportBtn);

      // Add cluster creation button
      const clusterBtn = document.createElement('button');
      clusterBtn.textContent = 'Create Cluster';
      clusterBtn.className = 'control-button';
      clusterBtn.style.position = 'absolute';
      clusterBtn.style.bottom = '3rem';
      clusterBtn.style.right = '1rem';
      clusterBtn.style.zIndex = '50';
      clusterBtn.onclick = () => app.createSynthesisCluster();
      document.querySelector('.aquarium-canvas').appendChild(clusterBtn);

      // Add reaction simulation button
      const reactionBtn = document.createElement('button');
      reactionBtn.textContent = 'Simulate Reaction';
      reactionBtn.className = 'control-button';
      reactionBtn.style.position = 'absolute';
      reactionBtn.style.bottom = '5rem';
      reactionBtn.style.right = '1rem';
      reactionBtn.style.zIndex = '50';
      reactionBtn.onclick = () => app.simulateChemicalReaction();
      document.querySelector('.aquarium-canvas').appendChild(reactionBtn);
    });

    // Global functions for event handlers
    window.app = {
      removeSynthesisOperation: (index) => app.removeSynthesisOperation(index),
      exportState: () => app.exportAquariumState(),
      createCluster: () => app.createSynthesisCluster(),
      simulateReaction: () => app.simulateChemicalReaction()
    };

    // Add advanced CSS for emergent elements
    const style = document.createElement('style');
    style.textContent = `
      .emergent-node {
        background: linear-gradient(45deg, 
          rgba(255, 255, 255, 0.1),
          rgba(212, 175, 55, 0.2),
          rgba(0, 212, 255, 0.1),
          rgba(106, 13, 173, 0.1)
        );
        border: 2px solid;
        border-image: linear-gradient(45deg, 
          var(--primary-gold), 
          var(--quantum-blue), 
          var(--void-purple)
        ) 1;
        animation: emergent-glow 3s ease-in-out infinite;
      }

      @keyframes emergent-glow {
        0%, 100% { 
          box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
          transform: scale(1);
        }
        50% { 
          box-shadow: 0 0 40px rgba(0, 212, 255, 0.5);
          transform: scale(1.05);
        }
      }

      .aquarium-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: 
          radial-gradient(circle at 20% 30%, rgba(0, 212, 255, 0.03) 0%, transparent 50%),
          radial-gradient(circle at 80% 70%, rgba(212, 175, 55, 0.03) 0%, transparent 50%),
          radial-gradient(circle at 50% 50%, rgba(106, 13, 173, 0.02) 0%, transparent 50%);
        pointer-events: none;
        animation: aquarium-flow 20s linear infinite;
      }

      @keyframes aquarium-flow {
        0% { 
          transform: translate(0, 0) rotate(0deg);
          opacity: 0.5;
        }
        25% { 
          transform: translate(10px, -5px) rotate(1deg);
          opacity: 0.7;
        }
        50% { 
          transform: translate(-5px, 10px) rotate(-0.5deg);
          opacity: 0.6;
        }
        75% { 
          transform: translate(-10px, -10px) rotate(0.5deg);
          opacity: 0.8;
        }
        100% { 
          transform: translate(0, 0) rotate(0deg);
          opacity: 0.5;
        }
      }

      .control-button {
        background: linear-gradient(135deg, var(--quantum-blue), var(--void-purple));
        color: var(--text-primary);
        font-family: 'JetBrains Mono', monospace;
        font-size: 0.7rem;
        border: none;
        padding: 0.5rem 0.75rem;
        border-radius: var(--border-radius);
        cursor: pointer;
        transition: var(--transition-smooth);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }

      .control-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 16px rgba(0, 212, 255, 0.3);
      }

      .floating-node {
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(8px);
      }

      .connection-line {
        filter: drop-shadow(0 0 3px currentColor);
      }

      .synthesis-cluster {
        backdrop-filter: blur(15px);
        border-image: linear-gradient(45deg, 
          var(--primary-gold), 
          transparent, 
          var(--primary-gold)
        ) 1;
        box-shadow: 0 8px 32px rgba(212, 175, 55, 0.2);
      }
    `;
    document.head.appendChild(style);
  </script>
</body>
</html>