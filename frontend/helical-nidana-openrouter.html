<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Helical Nidana-Alchemy Explorer</title>
  <style>
    :root {
      --primary-color: #6366f1;
      --secondary-color: #8b5cf6;
      --dark-bg: #111827;
      --darker-bg: #0f172a;
      --lighter-bg: #1f2937;
      --text-color: #f3f4f6;
      --muted-text: #9ca3af;
      --success-color: #10b981;
      --warning-color: #f59e0b;
      --error-color: #ef4444;
      --border-radius: 0.5rem;
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
        Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background-color: var(--darker-bg);
      color: var(--text-color);
      line-height: 1.5;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
    }
    
    .header {
      margin-bottom: 1.5rem;
    }
    
    .header h1 {
      font-size: 1.875rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 0 30px rgba(99, 102, 241, 0.3);
    }
    
    .header p {
      color: var(--muted-text);
      font-size: 0.875rem;
    }
    
    .main-content {
      display: flex;
      gap: 1rem;
      height: calc(100vh - 12rem);
      margin-bottom: 1rem;
    }
    
    .panel {
      background-color: var(--dark-bg);
      border-radius: var(--border-radius);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }
    
    .left-panel {
      width: 20%;
      overflow-y: auto;
    }
    
    .center-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    
    .right-panel {
      width: 30%;
      overflow-y: auto;
    }
    
    .helix-visualization {
      height: 300px;
      background-color: var(--darker-bg);
      margin-bottom: 1rem;
      border-radius: var(--border-radius);
      position: relative;
      overflow: hidden;
    }
    
    .panel-header {
      padding: 0.75rem 1rem;
      background-color: rgba(0, 0, 0, 0.2);
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .panel-header svg {
      width: 1rem;
      height: 1rem;
      margin-right: 0.5rem;
    }
    
    .panel-content {
      padding: 1rem;
    }
    
    .stages-list {
      list-style: none;
    }
    
    .stage-item {
      padding: 0.75rem;
      margin-bottom: 0.5rem;
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: all 0.2s ease;
      border-left: 3px solid transparent;
    }
    
    .stage-item:hover {
      background-color: rgba(255, 255, 255, 0.05);
    }
    
    .stage-item.active {
      background-color: rgba(99, 102, 241, 0.1);
      border-left-color: var(--primary-color);
    }
    
    .stage-header {
      display: flex;
      align-items: center;
      margin-bottom: 0.25rem;
    }
    
    .stage-symbol {
      margin-right: 0.5rem;
      font-family: serif;
      font-size: 1.25rem;
    }
    
    .stage-name {
      font-weight: 600;
      font-size: 0.875rem;
    }
    
    .stage-description {
      font-size: 0.75rem;
      color: var(--muted-text);
    }
    
    .progress-indicator {
      display: flex;
      padding: 0.5rem 1rem;
      background-color: rgba(0, 0, 0, 0.2);
      margin-bottom: 1rem;
    }
    
    .progress-step {
      flex: 1;
      height: 4px;
      background-color: rgba(255, 255, 255, 0.2);
      margin: 0 2px;
      border-radius: 2px;
      position: relative;
    }
    
    .progress-step.completed {
      background-color: var(--success-color);
    }
    
    .progress-step.active {
      background-color: var(--primary-color);
    }
    
    .input-section, .output-section {
      padding: 1rem;
      background-color: var(--dark-bg);
      border-radius: var(--border-radius);
      margin-bottom: 1rem;
    }
    
    .section-header {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }
    
    .section-header svg {
      width: 1rem;
      height: 1rem;
      margin-right: 0.5rem;
    }
    
    textarea, .output-content {
      width: 100%;
      background-color: var(--darker-bg);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 0.25rem;
      padding: 0.75rem;
      color: var(--text-color);
      font-family: inherit;
      font-size: 0.875rem;
      resize: none;
      min-height: 100px;
      margin-bottom: 0.75rem;
    }
    
    textarea:focus {
      outline: none;
      border-color: var(--primary-color);
    }
    
    .output-content {
      white-space: pre-line;
      overflow-y: auto;
      max-height: 300px;
    }
    
    .button-group {
      display: flex;
      gap: 0.5rem;
    }
    
    button {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.5rem 1rem;
      background-color: var(--lighter-bg);
      color: var(--text-color);
      border: none;
      border-radius: 0.25rem;
      cursor: pointer;
      font-size: 0.875rem;
      transition: all 0.2s ease;
    }
    
    button svg {
      width: 1rem;
      height: 1rem;
      margin-right: 0.5rem;
    }
    
    button:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    button.primary {
      background-color: var(--primary-color);
    }
    
    button.primary:hover {
      background-color: #4f46e5;
    }
    
    button.danger {
      background-color: var(--error-color);
    }
    
    button.danger:hover {
      background-color: #dc2626;
    }
    
    .settings-panel {
      margin-top: 1rem;
      padding: 1rem;
      background-color: var(--dark-bg);
      border-radius: var(--border-radius);
    }
    
    .settings-group {
      margin-bottom: 1rem;
    }
    
    .settings-group label {
      display: block;
      margin-bottom: 0.25rem;
      font-size: 0.75rem;
      color: var(--muted-text);
    }
    
    .settings-input {
      width: 100%;
      padding: 0.5rem;
      background-color: var(--darker-bg);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 0.25rem;
      color: var(--text-color);
      font-family: inherit;
      font-size: 0.875rem;
    }
    
    .settings-input:focus {
      outline: none;
      border-color: var(--primary-color);
    }
    
    .api-key-container {
      display: flex;
    }
    
    .api-key-container button {
      padding: 0.5rem;
    }
    
    .range-container {
      display: flex;
      align-items: center;
    }
    
    .range-container input {
      flex: 1;
      margin-right: 0.5rem;
    }
    
    .range-value {
      min-width: 2.5rem;
      text-align: right;
      font-size: 0.875rem;
    }
    
    .range-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: var(--muted-text);
      margin-top: 0.25rem;
    }
    
    .toggle-container {
      display: flex;
      align-items: center;
    }
    
    .toggle-container input {
      margin-right: 0.5rem;
    }
    
    .insight-list {
      list-style: none;
    }
    
    .insight-item {
      padding: 0.75rem;
      background-color: rgba(255, 255, 255, 0.05);
      border-radius: var(--border-radius);
      margin-bottom: 0.75rem;
      position: relative;
    }
    
    .insight-stage {
      font-size: 0.75rem;
      color: var(--muted-text);
      margin-bottom: 0.25rem;
    }
    
    .insight-text {
      font-size: 0.875rem;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
    }
    
    .insight-delete {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      background: none;
      border: none;
      color: var(--muted-text);
      cursor: pointer;
      padding: 0.25rem;
    }
    
    .insight-delete:hover {
      color: var(--error-color);
    }
    
    .helix-node {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-family: serif;
      font-size: 1.25rem;
      transition: all 0.3s ease;
    }
    
    .helix-node:hover {
      transform: scale(1.1);
    }
    
    .helix-connector {
      position: absolute;
      pointer-events: none;
      opacity: 0.3;
    }
    
    .prompt-template-list {
      list-style: none;
      margin-top: 0.5rem;
    }
    
    .prompt-template-item {
      padding: 0.5rem;
      background-color: rgba(255, 255, 255, 0.05);
      border-radius: 0.25rem;
      margin-bottom: 0.5rem;
      cursor: pointer;
    }
    
    .prompt-template-item:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }
    
    .notification {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      padding: 0.75rem 1rem;
      border-radius: var(--border-radius);
      color: white;
      max-width: 300px;
      display: flex;
      align-items: center;
      animation: slideIn 0.3s ease;
    }
    
    .notification.success {
      background-color: var(--success-color);
    }
    
    .notification.error {
      background-color: var(--error-color);
    }
    
    .notification svg {
      margin-right: 0.5rem;
    }
    
    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    .stat-container {
      background-color: rgba(255, 255, 255, 0.05);
      border-radius: var(--border-radius);
      padding: 0.5rem;
      margin-bottom: 0.5rem;
    }
    
    .stat-label {
      font-size: 0.75rem;
      color: var(--muted-text);
    }
    
    .stat-value {
      font-size: 0.875rem;
      font-weight: 600;
    }
    
    .icon-button {
      background: none;
      border: none;
      color: var(--muted-text);
      cursor: pointer;
      padding: 0.25rem;
    }
    
    .icon-button:hover {
      color: var(--text-color);
    }
    
    /* Helix specific styling */
    .helix-container {
      width: 100%;
      height: 100%;
      position: relative;
      perspective: 1000px;
    }
    
    .helix-wrapper {
      position: absolute;
      top: 50%;
      left: 50%;
      transform-style: preserve-3d;
      animation: helix-rotate 60s infinite linear;
      transition: transform 0.5s ease;
    }
    
    @keyframes helix-rotate {
      from { transform: translateX(-50%) translateY(-50%) rotateY(0deg); }
      to { transform: translateX(-50%) translateY(-50%) rotateY(360deg); }
    }
    
    .helix-controls {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      display: flex;
      gap: 0.25rem;
    }
    
    /* Loading spinner */
    .spinner {
      display: inline-block;
      width: 1.5rem;
      height: 1.5rem;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Mobile adjustments */
    @media (max-width: 768px) {
      .main-content {
        flex-direction: column;
        height: auto;
      }
      
      .left-panel, .right-panel {
        width: 100%;
        margin-bottom: 1rem;
      }
      
      .helix-visualization {
        height: 200px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header class="header">
      <h1>Helical Nidana-Alchemy Explorer</h1>
      <p>A guided journey through Buddhist nidanas and alchemical processes using LLM inference</p>
    </header>
    
    <div class="progress-indicator" id="progressBar">
      <!-- Progress steps will be inserted here -->
    </div>
    
    <div class="main-content">
      <div class="left-panel panel">
        <div class="panel-header">
          <span>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
            </svg>
            Stages of Transformation
          </span>
        </div>
        <div class="panel-content">
          <ul class="stages-list" id="stagesList">
            <!-- Stage items will be inserted here -->
          </ul>
        </div>
      </div>
      
      <div class="center-panel">
        <div class="helix-visualization panel" id="helixVisualization">
          <div class="helix-container">
            <div class="helix-wrapper" id="helixWrapper">
              <!-- Helix nodes will be inserted here -->
            </div>
          </div>
          <div class="helix-controls">
            <button class="icon-button" id="zoomIn" title="Zoom In">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="11" y1="8" x2="11" y2="14"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
              </svg>
            </button>
            <button class="icon-button" id="zoomOut" title="Zoom Out">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
              </svg>
            </button>
            <button class="icon-button" id="resetHelix" title="Reset View">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"></path>
              </svg>
            </button>
          </div>
        </div>
        
        <div class="input-section">
          <div class="section-header">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
            <span id="promptHeader">Prompt</span>
          </div>
          
          <div id="promptTemplatesContainer">
            <div class="button-group">
              <button id="useStagePrompt">Use Stage Prompt</button>
              <button id="useCustomPrompt">Use Custom Prompt</button>
            </div>
            <ul class="prompt-template-list" id="promptTemplateList">
              <!-- Prompt templates will be inserted here -->
            </ul>
          </div>
          
          <textarea id="promptInput" rows="4" placeholder="Enter your prompt here..."></textarea>
          
          <div class="button-group">
            <button class="primary" id="runInference">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="5 3 19 12 5 21 5 3"></polygon>
              </svg>
              Run Inference
            </button>
            <button class="danger" id="cancelInference" style="display: none;">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="15" y1="9" x2="9" y2="15"></line>
                <line x1="9" y1="9" x2="15" y2="15"></line>
              </svg>
              Cancel
            </button>
          </div>
        </div>
        
        <div class="output-section" id="outputSection" style="display: none;">
          <div class="section-header">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
              <line x1="8" y1="21" x2="16" y2="21"></line>
              <line x1="12" y1="17" x2="12" y2="21"></line>
            </svg>
            <span>Response</span>
            <div class="spinner" id="outputSpinner" style="display: none;"></div>
          </div>
          
          <div class="output-content" id="outputContent"></div>
          
          <div class="button-group">
            <button id="pinInsight">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                <circle cx="12" cy="10" r="3"></circle>
              </svg>
              Pin Insight
            </button>
            <button id="clearOutput">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
              </svg>
              Clear
            </button>
          </div>
          
          <div class="stats-container" id="statsContainer" style="margin-top: 1rem;">
            <div class="stat-container">
              <div class="stat-label">Estimated Tokens</div>
              <div class="stat-value" id="tokenCount">0</div>
            </div>
            <div class="stat-container">
              <div class="stat-label">Completion Time</div>
              <div class="stat-value" id="completionTime">0.0s</div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="right-panel panel">
        <div class="panel-header">
          <span>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path>
              <line x1="16" y1="8" x2="2" y2="22"></line>
              <line x1="17.5" y1="15" x2="9" y2="15"></line>
            </svg>
            Pinned Insights
          </span>
        </div>
        <div class="panel-content">
          <div id="insightsContainer">
            <ul class="insight-list" id="insightsList">
              <!-- Pinned insights will be inserted here -->
            </ul>
          </div>
          
          <div class="settings-panel">
            <div class="panel-header">
              <span>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="12" cy="12" r="3"></circle>
                  <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                </svg>
                API Settings
              </span>
            </div>
            
            <div class="settings-group">
              <label for="apiKey">OpenRouter API Key</label>
              <div class="api-key-container">
                <input type="text" id="apiKey" class="settings-input" value="">
                <button id="copyApiKey">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                  </svg>
                </button>
              </div>
            </div>
            
            <div class="settings-group">
              <label for="modelSelect">Model</label>
              <select id="modelSelect" class="settings-input">
                <option value="openai/gpt-3.5-turbo">GPT-3.5 Turbo - Fast & affordable</option>
                <option value="openai/gpt-4o">GPT-4o - Advanced reasoning</option>
                <option value="anthropic/claude-3-haiku">Claude 3 Haiku - Balanced performance</option>
                <option value="anthropic/claude-3-sonnet">Claude 3 Sonnet - High quality</option>
                <option value="anthropic/claude-3-opus">Claude 3 Opus - Most capable</option>
                <option value="meta/llama-3-8b-instruct">Llama 3 8B - Efficient</option>
                <option value="meta/llama-3-70b-instruct">Llama 3 70B - Strong performance</option>
              </select>
            </div>
            
            <div class="settings-group">
              <label>Temperature: <span id="temperatureValue">0.7</span></label>
              <div class="range-container">
                <input type="range" id="temperatureRange" min="0" max="1" step="0.1" value="0.7" class="settings-input">
              </div>
              <div class="range-labels">
                <span>Precise</span>
                <span>Creative</span>
              </div>
            </div>
            
            <div class="settings-group">
              <label>Max Tokens: <span id="maxTokensValue">500</span></label>
              <div class="range-container">
                <input type="range" id="maxTokensRange" min="100" max="2000" step="100" value="500" class="settings-input">
              </div>
              <div class="range-labels">
                <span>Brief</span>
                <span>Detailed</span>
              </div>
            </div>
            
            <div class="settings-group">
              <div class="toggle-container">
                <input type="checkbox" id="streamToggle" checked>
                <label for="streamToggle">Enable streaming responses</label>
              </div>
            </div>
            
            <div class="button-group">
              <button id="saveSettings">Save Settings</button>
              <button id="exportProgress">Export Progress</button>
              <button id="importProgress">Import Progress</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <div id="notification" style="display: none;" class="notification">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
      <polyline points="22 4 12 14.01 9 11.01"></polyline>
    </svg>
    <span id="notificationText"></span>
  </div>
  
  <script>
    // Core data structures and constants
    const NIDANA_ALCHEMY_MAPPING = [
      {
        id: 'avidya-prima',
        nidana: { id: 'avidya', name: 'Avidya', description: 'Ignorance', symbol: '無明' },
        alchemy: { id: 'prima-materia', name: 'Prima Materia', description: 'First matter', symbol: '☉' },
        color: '#3b82f6',
        description: 'Beginning with the raw material of consciousness and data',
        apiSettings: { temperature: 0.7, maxTokens: 300 }
      },
      {
        id: 'samskara-calcinatio',
        nidana: { id: 'samskara', name: 'Samskara', description: 'Mental formations', symbol: '行' },
        alchemy: { id: 'calcinatio', name: 'Calcinatio', description: 'Purification', symbol: '🜂' },
        color: '#f59e0b',
        description: 'Purifying ideas through heat of focused attention',
        apiSettings: { temperature: 0.5, maxTokens: 500 }
      },
      {
        id: 'vijnana-solutio',
        nidana: { id: 'vijnana', name: 'Vijnana', description: 'Consciousness', symbol: '識' },
        alchemy: { id: 'solutio', name: 'Solutio', description: 'Dissolution', symbol: '🜄' },
        color: '#10b981',
        description: 'Dissolving rigid thought patterns to reveal deeper insights',
        apiSettings: { temperature: 0.8, maxTokens: 600 }
      },
      {
        id: 'namarupa-coagulatio',
        nidana: { id: 'namarupa', name: 'Namarupa', description: 'Name and form', symbol: '名色' },
        alchemy: { id: 'coagulatio', name: 'Coagulatio', description: 'Solidification', symbol: '🜏' },
        color: '#8b5cf6',
        description: 'Giving concrete form to abstract concepts',
        apiSettings: { temperature: 1.0, maxTokens: 400 }
      },
      {
        id: 'sadayatana-sublimatio',
        nidana: { id: 'sadayatana', name: 'Sadayatana', description: 'Six sense bases', symbol: '六入' },
        alchemy: { id: 'sublimatio', name: 'Sublimatio', description: 'Refinement', symbol: '🜎' },
        color: '#ec4899',
        description: 'Elevating understanding to higher perspectives',
        apiSettings: { temperature: 0.9, maxTokens: 700 }
      }
    ];
    
    const PROMPT_TEMPLATES = {
      'avidya-prima': [
        {
          name: 'Concept Exploration',
          template: 'Provide a basic explanation of {{concept}} without assuming any prior knowledge.'
        },
        {
          name: 'Term Definition',
          template: 'Define the following term in simple language: {{term}}'
        },
        {
          name: 'Knowledge Assessment',
          template: 'What are the fundamental principles of {{domain}}?'
        }
      ],
      'samskara-calcinatio': [
        {
          name: 'Core Extraction',
          template: 'Identify and explain the 5 most essential concepts in {{domain}}.'
        },
        {
          name: 'Misconception Burning',
          template: 'What are the most common misconceptions about {{concept}} and how would you correct them?'
        },
        {
          name: 'Principle Distillation',
          template: 'Distill {{text}} to its core principles and key insights.'
        }
      ],
      'vijnana-solutio': [
        {
          name: 'Mental Model Dissolution',
          template: 'Challenge the conventional thinking about {{concept}} by highlighting its inherent contradictions.'
        },
        {
          name: 'Boundary Dissolution',
          template: 'How might {{concept1}} and {{concept2}} be two aspects of the same phenomenon?'
        },
        {
          name: 'Assumption Questioning',
          template: 'What key assumptions about {{domain}} might be limiting our understanding?'
        }
      ],
      'namarupa-coagulatio': [
        {
          name: 'Concrete Metaphor',
          template: 'Create a detailed, concrete metaphor that makes {{concept}} intuitive to beginners.'
        },
        {
          name: 'Pattern Recognition',
          template: 'What recurring patterns can be identified in {{domain}}?'
        },
        {
          name: 'Structure Mapping',
          template: 'Map the structure of {{concept}} as a system with interconnected parts.'
        }
      ],
      'sadayatana-sublimatio': [
        {
          name: 'Higher Perspective',
          template: 'What higher-order implications might {{concept}} have for society?'
        },
        {
          name: 'Meta-Analysis',
          template: 'Analyze {{domain}} from a meta-level perspective, reflecting on patterns across the entire field.'
        },
        {
          name: 'Perceptual Shift',
          template: 'How would our understanding of {{concept}} change if viewed through six different lenses or frameworks?'
        }
      ]
    };
    
    // Default prompt placeholders
    const DEFAULT_PLACEHOLDERS = {
      'concept': 'quantum computing',
      'concept1': 'consciousness',
      'concept2': 'computation',
      'domain': 'artificial intelligence',
      'term': 'qubit',
      'text': 'Quantum computers use quantum bits or qubits, which can exist in multiple states simultaneously due to superposition. This allows them to perform certain computations exponentially faster than classical computers by exploring many possibilities at once.'
    };
    
    // Application state
    let state = {
      currentStage: 0,
      activeMapping: NIDANA_ALCHEMY_MAPPING[0],
      useCustomPrompt: false,
      customPrompt: '',
      responses: {},
      insights: [],
      isLoading: false,
      streamController: null,
      streamingResponse: '',
      apiSettings: {
        apiKey: 'none',
        model: 'openai/gpt-3.5-turbo',
        temperature: 0.7,
        maxTokens: 500,
        streamMode: true
      },
      helixSettings: {
        zoom: 1,
        rotation: { x: 0, y: 0 }
      },
      stats: {
        tokens: 0,
        completionTime: 0
      },
      completedStages: new Set()
    };
    
    // DOM elements
    const elements = {
      stagesList: document.getElementById('stagesList'),
      progressBar: document.getElementById('progressBar'),
      helixVisualization: document.getElementById('helixVisualization'),
      helixWrapper: document.getElementById('helixWrapper'),
      zoomIn: document.getElementById('zoomIn'),
      zoomOut: document.getElementById('zoomOut'),
      resetHelix: document.getElementById('resetHelix'),
      promptHeader: document.getElementById('promptHeader'),
      promptTemplatesContainer: document.getElementById('promptTemplatesContainer'),
      promptTemplateList: document.getElementById('promptTemplateList'),
      useStagePrompt: document.getElementById('useStagePrompt'),
      useCustomPrompt: document.getElementById('useCustomPrompt'),
      promptInput: document.getElementById('promptInput'),
      runInference: document.getElementById('runInference'),
      cancelInference: document.getElementById('cancelInference'),
      outputSection: document.getElementById('outputSection'),
      outputContent: document.getElementById('outputContent'),
      outputSpinner: document.getElementById('outputSpinner'),
      pinInsight: document.getElementById('pinInsight'),
      clearOutput: document.getElementById('clearOutput'),
      insightsList: document.getElementById('insightsList'),
      apiKey: document.getElementById('apiKey'),
      copyApiKey: document.getElementById('copyApiKey'),
      modelSelect: document.getElementById('modelSelect'),
      temperatureRange: document.getElementById('temperatureRange'),
      temperatureValue: document.getElementById('temperatureValue'),
      maxTokensRange: document.getElementById('maxTokensRange'),
      maxTokensValue: document.getElementById('maxTokensValue'),
      streamToggle: document.getElementById('streamToggle'),
      saveSettings: document.getElementById('saveSettings'),
      exportProgress: document.getElementById('exportProgress'),
      importProgress: document.getElementById('importProgress'),
      notification: document.getElementById('notification'),
      notificationText: document.getElementById('notificationText'),
      tokenCount: document.getElementById('tokenCount'),
      completionTime: document.getElementById('completionTime'),
      statsContainer: document.getElementById('statsContainer')
    };
    
    // Initialize the application
    function initializeApp() {
      // Load saved state from localStorage if available
      loadStateFromStorage();
      
      // Render the UI components
      renderStagesList();
      renderProgressBar();
      renderHelix();
      renderPromptTemplates();
      renderInsights();
      updateSettingsUI();
      
      // Set up event listeners
      setupEventListeners();
      
      // Show notification on startup
      showNotification('Welcome to the Helical Nidana-Alchemy Explorer!', 'success');
    }
    
    // Local storage functions
    function saveStateToStorage() {
      try {
        // Filter out non-serializable parts of the state
        const stateToSave = {
          currentStage: state.currentStage,
          useCustomPrompt: state.useCustomPrompt,
          customPrompt: state.customPrompt,
          responses: state.responses,
          insights: state.insights,
          apiSettings: state.apiSettings,
          helixSettings: state.helixSettings,
          completedStages: Array.from(state.completedStages)
        };
        
        localStorage.setItem('helicalNidanaState', JSON.stringify(stateToSave));
        return true;
      } catch (error) {
        console.error('Failed to save state:', error);
        return false;
      }
    }
    
    function loadStateFromStorage() {
      try {
        const savedState = localStorage.getItem('helicalNidanaState');
        if (savedState) {
          const parsedState = JSON.parse(savedState);
          
          // Update state with saved values, keeping the current structure
          state.currentStage = parsedState.currentStage || 0;
          state.activeMapping = NIDANA_ALCHEMY_MAPPING[state.currentStage];
          state.useCustomPrompt = parsedState.useCustomPrompt || false;
          state.customPrompt = parsedState.customPrompt || '';
          state.responses = parsedState.responses || {};
          state.insights = parsedState.insights || [];
          state.apiSettings = {
            ...state.apiSettings,
            ...parsedState.apiSettings
          };
          state.helixSettings = parsedState.helixSettings || { zoom: 1, rotation: { x: 0, y: 0 } };
          state.completedStages = new Set(parsedState.completedStages || []);
        }
      } catch (error) {
        console.error('Failed to load state:', error);
      }
    }
    
    function exportStateAsJson() {
      try {
        const stateToExport = {
          currentStage: state.currentStage,
          useCustomPrompt: state.useCustomPrompt,
          customPrompt: state.customPrompt,
          responses: state.responses,
          insights: state.insights,
          apiSettings: state.apiSettings,
          helixSettings: state.helixSettings,
          completedStages: Array.from(state.completedStages)
        };
        
        const blob = new Blob([JSON.stringify(stateToExport, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'helical-nidana-journey.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showNotification('Journey exported successfully!', 'success');
      } catch (error) {
        console.error('Failed to export state:', error);
        showNotification('Failed to export journey', 'error');
      }
    }
    
    function importStateFromJson() {
      try {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        
        input.onchange = e => {
          const file = e.target.files[0];
          const reader = new FileReader();
          
          reader.onload = event => {
            try {
              const importedState = JSON.parse(event.target.result);
              
              // Update state with imported values
              state.currentStage = importedState.currentStage || 0;
              state.activeMapping = NIDANA_ALCHEMY_MAPPING[state.currentStage];
              state.useCustomPrompt = importedState.useCustomPrompt || false;
              state.customPrompt = importedState.customPrompt || '';
              state.responses = importedState.responses || {};
              state.insights = importedState.insights || [];
              state.apiSettings = {
                ...state.apiSettings,
                ...importedState.apiSettings
              };
              state.helixSettings = importedState.helixSettings || { zoom: 1, rotation: { x: 0, y: 0 } };
              state.completedStages = new Set(importedState.completedStages || []);
              
              // Update UI to reflect the imported state
              renderStagesList();
              renderProgressBar();
              renderHelix();
              renderPromptTemplates();
              renderInsights();
              updateSettingsUI();
              
              saveStateToStorage();
              showNotification('Journey imported successfully!', 'success');
            } catch (error) {
              console.error('Failed to parse imported file:', error);
              showNotification('Invalid journey file', 'error');
            }
          };
          
          reader.readAsText(file);
        };
        
        input.click();
      } catch (error) {
        console.error('Failed to import state:', error);
        showNotification('Failed to import journey', 'error');
      }
    }
    
    // UI Rendering Functions
    function renderStagesList() {
      elements.stagesList.innerHTML = '';
      
      NIDANA_ALCHEMY_MAPPING.forEach((mapping, index) => {
        const listItem = document.createElement('li');
        listItem.className = `stage-item${index === state.currentStage ? ' active' : ''}`;
        listItem.style.borderLeftColor = mapping.color;
        
        // Mark completed stages
        if (state.completedStages.has(mapping.id)) {
          listItem.style.backgroundColor = `${mapping.color}22`;
        }
        
        listItem.innerHTML = `
          <div class="stage-header">
            <span class="stage-symbol">${mapping.nidana.symbol}</span>
            <span class="stage-name">${mapping.nidana.name} / ${mapping.alchemy.name}</span>
          </div>
          <div class="stage-description">${mapping.description}</div>
        `;
        
        listItem.addEventListener('click', () => {
          state.currentStage = index;
          state.activeMapping = mapping;
          renderStagesList();
          renderPromptTemplates();
          updatePromptUI();
        });
        
        elements.stagesList.appendChild(listItem);
      });
    }
    
    function renderProgressBar() {
      elements.progressBar.innerHTML = '';
      
      NIDANA_ALCHEMY_MAPPING.forEach((mapping, index) => {
        const progressStep = document.createElement('div');
        progressStep.className = `progress-step${state.completedStages.has(mapping.id) ? ' completed' : ''}${index === state.currentStage ? ' active' : ''}`;
        progressStep.style.backgroundColor = index === state.currentStage ? mapping.color : state.completedStages.has(mapping.id) ? `${mapping.color}99` : '';
        
        progressStep.addEventListener('click', () => {
          state.currentStage = index;
          state.activeMapping = mapping;
          renderStagesList();
          renderProgressBar();
          renderPromptTemplates();
          updatePromptUI();
        });
        
        elements.progressBar.appendChild(progressStep);
      });
    }
    
    function renderHelix() {
      elements.helixWrapper.innerHTML = '';
      
      // Calculate helix positions
      const positions = calculateHelixPositions(NIDANA_ALCHEMY_MAPPING.length);
      
      // Create nodes for each position
      NIDANA_ALCHEMY_MAPPING.forEach((mapping, index) => {
        const { nidana, alchemy } = positions[index];
        
        // Create nidana node
        const nidanaNode = document.createElement('div');
        nidanaNode.className = 'helix-node';
        nidanaNode.style.backgroundColor = `${mapping.color}22`;
        nidanaNode.style.border = `2px solid ${mapping.color}`;
        nidanaNode.style.transform = `translate3d(${nidana.x}px, ${nidana.y}px, ${nidana.z}px)`;
        nidanaNode.innerHTML = mapping.nidana.symbol;
        nidanaNode.dataset.index = index;
        nidanaNode.dataset.type = 'nidana';
        
        if (state.completedStages.has(mapping.id)) {
          nidanaNode.style.backgroundColor = `${mapping.color}44`;
          nidanaNode.style.boxShadow = `0 0 10px ${mapping.color}`;
        }
        
        nidanaNode.addEventListener('click', () => {
          state.currentStage = index;
          state.activeMapping = mapping;
          renderStagesList();
          renderProgressBar();
          renderPromptTemplates();
          updatePromptUI();
        });
        
        // Create alchemy node
        const alchemyNode = document.createElement('div');
        alchemyNode.className = 'helix-node';
        alchemyNode.style.backgroundColor = `${mapping.color}22`;
        alchemyNode.style.border = `2px solid ${mapping.color}`;
        alchemyNode.style.transform = `translate3d(${alchemy.x}px, ${alchemy.y}px, ${alchemy.z}px)`;
        alchemyNode.innerHTML = mapping.alchemy.symbol;
        alchemyNode.dataset.index = index;
        alchemyNode.dataset.type = 'alchemy';
        
        if (state.completedStages.has(mapping.id)) {
          alchemyNode.style.backgroundColor = `${mapping.color}44`;
          alchemyNode.style.boxShadow = `0 0 10px ${mapping.color}`;
        }
        
        alchemyNode.addEventListener('click', () => {
          state.currentStage = index;
          state.activeMapping = mapping;
          renderStagesList();
          renderProgressBar();
          renderPromptTemplates();
          updatePromptUI();
        });
        
        // Create connector between nodes
        const connector = document.createElement('div');
        connector.className = 'helix-connector';
        connector.style.width = `${Math.sqrt(Math.pow(alchemy.x - nidana.x, 2) + Math.pow(alchemy.z - nidana.z, 2))}px`;
        connector.style.height = '1px';
        connector.style.backgroundColor = mapping.color;
        connector.style.transform = `translate3d(${(nidana.x + alchemy.x) / 2}px, ${nidana.y}px, ${(nidana.z + alchemy.z) / 2}px) rotateY(${Math.atan2(alchemy.z - nidana.z, alchemy.x - nidana.x)}rad)`;
        
        elements.helixWrapper.appendChild(nidanaNode);
        elements.helixWrapper.appendChild(alchemyNode);
        elements.helixWrapper.appendChild(connector);
      });
      
      // Apply current zoom and rotation
      updateHelixTransform();
    }
    
    function calculateHelixPositions(numPoints) {
      const positions = [];
      const radius = 80;
      const height = 300;
      const turns = 1.2;
      const angleStep = (Math.PI * 2 * turns) / numPoints;
      const heightStep = height / numPoints;
      
      for (let i = 0; i < numPoints; i++) {
        const angle = i * angleStep;
        const y = i * heightStep - height / 2;
        const x = radius * Math.cos(angle);
        const z = radius * Math.sin(angle);
        
        // Calculate position for paired element (on opposite side of helix)
        const oppositeAngle = angle + Math.PI;
        const oppositeX = radius * Math.cos(oppositeAngle);
        const oppositeZ = radius * Math.sin(oppositeAngle);
        
        positions.push({
          nidana: { x, y, z },
          alchemy: { x: oppositeX, y, z: oppositeZ }
        });
      }
      
      return positions;
    }
    
    function updateHelixTransform() {
      elements.helixWrapper.style.transform = `translateX(-50%) translateY(-50%) scale(${state.helixSettings.zoom}) rotateX(${state.helixSettings.rotation.x}deg) rotateY(${state.helixSettings.rotation.y}deg)`;
    }
    
    function renderPromptTemplates() {
      const { activeMapping, useCustomPrompt } = state;
      const templates = PROMPT_TEMPLATES[activeMapping.id] || [];
      
      // Update prompt header
      elements.promptHeader.textContent = `Prompt - ${activeMapping.nidana.name} / ${activeMapping.alchemy.name}`;
      
      // Toggle button states
      elements.useStagePrompt.className = useCustomPrompt ? '' : 'primary';
      elements.useCustomPrompt.className = useCustomPrompt ? 'primary' : '';
      
      // Render templates
      elements.promptTemplateList.innerHTML = '';
      
      templates.forEach(template => {
        const listItem = document.createElement('li');
        listItem.className = 'prompt-template-item';
        listItem.textContent = template.name;
        
        listItem.addEventListener('click', () => {
          applyPromptTemplate(template.template);
        });
        
        elements.promptTemplateList.appendChild(listItem);
      });
      
      // Update the prompt input
      updatePromptUI();
    }
    
    function updatePromptUI() {
      const { activeMapping, useCustomPrompt, customPrompt, responses } = state;
      
      if (useCustomPrompt) {
        elements.promptInput.value = customPrompt;
      } else {
        // Use the first template as default
        const templates = PROMPT_TEMPLATES[activeMapping.id] || [];
        if (templates.length > 0) {
          let template = templates[0].template;
          
          // Fill placeholders with default values
          for (const [key, value] of Object.entries(DEFAULT_PLACEHOLDERS)) {
            template = template.replace(`{{${key}}}`, value);
          }
          
          elements.promptInput.value = template;
        } else {
          elements.promptInput.value = '';
        }
      }
      
      // Show/hide output section based on whether there's a response
      const hasResponse = responses[activeMapping.id];
      elements.outputSection.style.display = hasResponse ? 'block' : 'none';
      
      if (hasResponse) {
        elements.outputContent.textContent = responses[activeMapping.id];
      }
    }
    
    function renderInsights() {
      elements.insightsList.innerHTML = '';
      
      if (state.insights.length === 0) {
        const emptyMessage = document.createElement('div');
        emptyMessage.className = 'text-center p-4 text-gray-400 text-sm';
        emptyMessage.textContent = 'No insights pinned yet. Generate responses and pin your discoveries here.';
        elements.insightsList.appendChild(emptyMessage);
        return;
      }
      
      state.insights.forEach((insight, index) => {
        const insightItem = document.createElement('li');
        insightItem.className = 'insight-item';
        insightItem.style.borderLeft = `3px solid ${insight.color}`;
        
        insightItem.innerHTML = `
          <div class="insight-stage">${insight.stageName}</div>
          <div class="insight-text">${insight.text.substring(0, 150)}${insight.text.length > 150 ? '...' : ''}</div>
          <button class="insight-delete" data-index="${index}">
            <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        `;
        
        // Add click handlers
        const deleteButton = insightItem.querySelector('.insight-delete');
        deleteButton.addEventListener('click', () => {
          state.insights.splice(index, 1);
          renderInsights();
          saveStateToStorage();
        });
        
        // Make the insight expandable
        insightItem.addEventListener('click', (e) => {
          if (e.target !== deleteButton && !deleteButton.contains(e.target)) {
            showNotification(insight.text, 'success', 10000);
          }
        });
        
        elements.insightsList.appendChild(insightItem);
      });
    }
    
    function updateSettingsUI() {
      const { apiSettings } = state;
      
      elements.apiKey.value = apiSettings.apiKey;
      elements.modelSelect.value = apiSettings.model;
      elements.temperatureRange.value = apiSettings.temperature;
      elements.temperatureValue.textContent = apiSettings.temperature;
      elements.maxTokensRange.value = apiSettings.maxTokens;
      elements.maxTokensValue.textContent = apiSettings.maxTokens;
      elements.streamToggle.checked = apiSettings.streamMode;
    }
    
    function updateStatsUI() {
      elements.tokenCount.textContent = state.stats.tokens;
      elements.completionTime.textContent = `${(state.stats.completionTime / 1000).toFixed(1)}s`;
    }
    
    // Event Listeners
    function setupEventListeners() {
      // Prompt type toggle
      elements.useStagePrompt.addEventListener('click', () => {
        state.useCustomPrompt = false;
        renderPromptTemplates();
      });
      
      elements.useCustomPrompt.addEventListener('click', () => {
        state.useCustomPrompt = true;
        state.customPrompt = elements.promptInput.value;
        renderPromptTemplates();
      });
      
      // Prompt input changes
      elements.promptInput.addEventListener('input', () => {
        if (state.useCustomPrompt) {
          state.customPrompt = elements.promptInput.value;
        }
      });
      
      // Run inference
      elements.runInference.addEventListener('click', () => {
        runInference();
      });
      
      // Cancel inference
      elements.cancelInference.addEventListener('click', () => {
        cancelInference();
      });
      
      // Pin insight
      elements.pinInsight.addEventListener('click', () => {
        if (state.responses[state.activeMapping.id]) {
          state.insights.push({
            id: Date.now(),
            stageId: state.activeMapping.id,
            stageName: `${state.activeMapping.nidana.name} / ${state.activeMapping.alchemy.name}`,
            text: state.responses[state.activeMapping.id],
            color: state.activeMapping.color
          });
          
          renderInsights();
          saveStateToStorage();
          showNotification('Insight pinned successfully!', 'success');
        }
      });
      
      // Clear output
      elements.clearOutput.addEventListener('click', () => {
        delete state.responses[state.activeMapping.id];
        elements.outputSection.style.display = 'none';
        saveStateToStorage();
      });
      
      // API settings
      elements.apiKey.addEventListener('input', () => {
        state.apiSettings.apiKey = elements.apiKey.value;
      });
      
      elements.modelSelect.addEventListener('change', () => {
        state.apiSettings.model = elements.modelSelect.value;
      });
      
      elements.temperatureRange.addEventListener('input', () => {
        state.apiSettings.temperature = parseFloat(elements.temperatureRange.value);
        elements.temperatureValue.textContent = state.apiSettings.temperature;
      });
      
      elements.maxTokensRange.addEventListener('input', () => {
        state.apiSettings.maxTokens = parseInt(elements.maxTokensRange.value);
        elements.maxTokensValue.textContent = state.apiSettings.maxTokens;
      });
      
      elements.streamToggle.addEventListener('change', () => {
        state.apiSettings.streamMode = elements.streamToggle.checked;
      });
      
      // Copy API key
      elements.copyApiKey.addEventListener('click', () => {
        navigator.clipboard.writeText(elements.apiKey.value);
        showNotification('API key copied to clipboard', 'success');
      });
      
      // Save settings
      elements.saveSettings.addEventListener('click', () => {
        saveStateToStorage();
        showNotification('Settings saved successfully!', 'success');
      });
      
      // Export progress
      elements.exportProgress.addEventListener('click', () => {
        exportStateAsJson();
      });
      
      // Import progress
      elements.importProgress.addEventListener('click', () => {
        importStateFromJson();
      });
      
      // Helix controls
      elements.zoomIn.addEventListener('click', () => {
        state.helixSettings.zoom = Math.min(state.helixSettings.zoom + 0.1, 2);
        updateHelixTransform();
      });
      
      elements.zoomOut.addEventListener('click', () => {
        state.helixSettings.zoom = Math.max(state.helixSettings.zoom - 0.1, 0.5);
        updateHelixTransform();
      });
      
      elements.resetHelix.addEventListener('click', () => {
        state.helixSettings = { zoom: 1, rotation: { x: 0, y: 0 } };
        updateHelixTransform();
      });
      
      // Helix mouse interaction
      let isDragging = false;
      let lastMousePosition = { x: 0, y: 0 };
      
      elements.helixVisualization.addEventListener('mousedown', (e) => {
        if (e.target.classList.contains('helix-node')) return;
        
        isDragging = true;
        lastMousePosition = { x: e.clientX, y: e.clientY };
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        const deltaX = e.clientX - lastMousePosition.x;
        const deltaY = e.clientY - lastMousePosition.y;
        
        state.helixSettings.rotation.y += deltaX * 0.5;
        state.helixSettings.rotation.x += deltaY * 0.5;
        
        updateHelixTransform();
        
        lastMousePosition = { x: e.clientX, y: e.clientY };
      });
      
      document.addEventListener('mouseup', () => {
        isDragging = false;
      });
    }
    
    // Helper Functions
    function applyPromptTemplate(template) {
      // Fill placeholders with default values
      let filledTemplate = template;
      
      for (const [key, value] of Object.entries(DEFAULT_PLACEHOLDERS)) {
        filledTemplate = filledTemplate.replace(`{{${key}}}`, value);
      }
      
      elements.promptInput.value = filledTemplate;
      
      if (state.useCustomPrompt) {
        state.customPrompt = filledTemplate;
      }
    }
    
    function showNotification(message, type = 'success', duration = 3000) {
      elements.notification.className = `notification ${type}`;
      elements.notificationText.textContent = message;
      elements.notification.style.display = 'flex';
      
      setTimeout(() => {
        elements.notification.style.display = 'none';
      }, duration);
    }
    
    // LLM Inference Functions
    function runInference() {
      if (state.isLoading) return;
      
      const prompt = elements.promptInput.value.trim();
      if (!prompt) {
        showNotification('Please enter a prompt', 'error');
        return;
      }
      
      const apiKey = state.apiSettings.apiKey;
      // if (!apiKey) {
      //   showNotification('Please enter an API key', 'error');
      //   return;
      // }
      
      // Update UI
      state.isLoading = true;
      elements.runInference.disabled = true;
      elements.outputSection.style.display = 'block';
      elements.outputContent.textContent = '';
      elements.outputSpinner.style.display = 'inline-block';
      elements.cancelInference.style.display = 'flex';
      
      // Initialize stats
      state.stats = {
        tokens: 0,
        completionTime: 0,
        startTime: Date.now()
      };
      
      // Create abort controller
      const controller = new AbortController();
      state.streamController = controller;
      
      // Make API call
      streamLLMResponse(apiKey, prompt, controller.signal)
        .then(response => {
          // Update state and UI
          state.responses[state.activeMapping.id] = response;
          state.completedStages.add(state.activeMapping.id);
          state.isLoading = false;
          
          // Calculate stats
          state.stats.completionTime = Date.now() - state.stats.startTime;
          state.stats.tokens = response.split(/\s+/).length;
          
          // Update UI
          elements.outputContent.textContent = response;
          elements.outputSpinner.style.display = 'none';
          elements.runInference.disabled = false;
          elements.cancelInference.style.display = 'none';
          updateStatsUI();
          
          // Save state
          saveStateToStorage();
          
          // Update rendered components
          renderStagesList();
          renderProgressBar();
          renderHelix();
        })
        .catch(error => {
          if (error.name !== 'AbortError') {
            showNotification(`Error: ${error.message}`, 'error');
            console.error('Inference error:', error);
          }
          
          state.isLoading = false;
          elements.outputSpinner.style.display = 'none';
          elements.runInference.disabled = false;
          elements.cancelInference.style.display = 'none';
        });
    }
    
    function cancelInference() {
      if (state.streamController) {
        state.streamController.abort();
        state.streamController = null;
        state.isLoading = false;
        elements.outputSpinner.style.display = 'none';
        elements.runInference.disabled = false;
        elements.cancelInference.style.display = 'none';
        showNotification('Inference cancelled', 'error');
      }
    }
    
    async function streamLLMResponse(apiKey, prompt, signal) {
      const modelName = state.apiSettings.model;
      const temperature = state.apiSettings.temperature;
      const maxTokens = state.apiSettings.maxTokens;
      const streamMode = state.apiSettings.streamMode;
      
      try {
        // Prepare request
        const requestBody = {
          model: modelName,
          messages: [{ role: 'user', content: prompt }],
          stream: streamMode,
          temperature: temperature,
          max_tokens: maxTokens
        };
        
        // Make request
        const response = await fetch('/api-v1/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json',
            'HTTP-Referer': window.location.origin
          },
          body: JSON.stringify(requestBody),
          signal: signal
        });
        
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error?.message || 'Error connecting to OpenRouter API');
        }
        
        // Handle streaming response
        if (streamMode) {
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = '';
          let fullText = '';
          
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            
            // Append new chunk to buffer
            buffer += decoder.decode(value, { stream: true });
            
            // Process complete lines from buffer
            while (true) {
              const lineEnd = buffer.indexOf('\n');
              if (lineEnd === -1) break;
              const line = buffer.slice(0, lineEnd).trim();
              buffer = buffer.slice(lineEnd + 1);
              
              if (line.startsWith('data: ')) {
                const data = line.slice(6);
                if (data === '[DONE]') break;
                
                try {
                  const parsed = JSON.parse(data);
                  const content = parsed.choices[0].delta.content;
                  if (content) {
                    fullText += content;
                    elements.outputContent.textContent = fullText;
                  }
                } catch (e) {
                  // Ignore invalid JSON
                }
              }
            }
          }
          
          return fullText;
        } 
        // Handle non-streaming response
        else {
          const data = await response.json();
          return data.choices[0].message.content;
        }
      } catch (error) {
        throw error;
      }
    }
    
    // Initialize the application
    document.addEventListener('DOMContentLoaded', initializeApp);
  </script>
</body>
</html>
